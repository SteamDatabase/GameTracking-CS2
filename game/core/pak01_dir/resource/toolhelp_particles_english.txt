"lang"
{
	"Tokens"
	{
		"Attribute.C_OP_BasicMovement.m_Gravity"		"Gravity"
		"Attribute.C_OP_BasicMovement.m_Gravity:help"		"Gravitational effect on the particles."
		"Element.C_OP_RenderTrailsWithRenderSystem"		"Render Trails"
		"Element.C_OP_RenderTrailsWithRenderSystem:help"		"Render sprite trails"
		"Element.C_OP_RenderSpritesWithRenderSystem"		"Render Sprites"
		"Element.C_OP_RenderSpritesWithRenderSystem:help"		"Render sprites"
		"Element.C_OP_RenderRopesWithRenderSystem"		"Render Ropes"
		"Element.C_OP_RenderRopesWithRenderSystem:help"		"Render ropes"
		"Element.C_OP_RenderGrid"		"Render Grid"
		"Element.C_OP_RenderGrid:help"		"Render particles in a grid (ie. cloth)"
		"Attribute.C_OP_RenderSpritesWithRenderSystem.m_flMaxSize"		"Max Visual Size"
		"Attribute.C_OP_RenderSpritesWithRenderSystem.m_flMaxSize:help"		"Individual particles will never render larger than this number as a fraction of screen size. (0.5 is 50% of the screen)"
		"Attribute.C_OP_RenderSpritesWithRenderSystem.m_flMinSize"		"Min Visual Size"
		"Attribute.C_OP_RenderSpritesWithRenderSystem.m_flMinSize:help"		"Individual particles will never render smaller than this number as a fraction of screen size. (0.5 is 50% of the screen)"
		"Element.CParticleSystemDefinition"		"Base Properties"
		"Element.CParticleSystemDefinition:help"		"<i>For a general introduction to the particle effect engine and tools, please visit <a href = \"https://developer.valvesoftware.com/wiki/Particle_Editor\">the Valve Developer Community page</a>.</i>
<p>These are the core properties of the effect. Most of these lie outside the scope of operators, and many define low-level engine settings that are generally left to their default values.</p>
<p>The properties that will most commonly be modified are:</p>
<ul>
<li><b>initial_particles</b>
<li><b>bounding_box_min</b> and <b>bounding_box_max</b>
<li>fallback replacement definition
<li>view model effect
<li>screen space effect
<li><b>max_particles</b>
</ul>
<p>Additionally, some properties are here to provide a simple mechanism for defining effect defaults which can then be overridden by operators when necessary. These include:</p>
<ul>
<li><b>color</b>
<li><b>radius</b>
<li><b>rotation</b>
<li><b>rotation_speed</b>
<li><b>lifetime</b>
<li><b>sequence_number</b>
<li><b>sequence_number 1</b>"
		"Element.C_OP_Decay"		"Lifespan Decay"
		"Element.C_OP_Decay:help"		"<p>This enables particles to be destroyed by the effect.</p>
<p>All effects should have a Decay Operator (usually Lifespan Decay) unless you're certain that the particles will get destroyed by some other means (usually code.)</p>"
		"Attribute.CParticleOperatorInstance.m_Notes"		"Operator Help and Notes"
		"Attribute.CParticleOperatorInstance.m_Notes:help"		"<p>Adding comments to your effects can be useful if there are multiple artists passing files around.</p>
<p>Sometimes it's even helpful to maintain effect documentation for yourself - particularly if you've got a complex or fragile setup that isn't self-evident just by looking at the effect. (For example, if you're using a lot of non-standard data being passed via CPs from the engine, or if you're making heavy use of Operator Fade/Time Offset/Strength Modifiers/Timescale Modifiers.)</p>"
		"Element.C_OP_BasicMovement"		"Movement Basic"
		"Element.C_OP_BasicMovement:help"		"<p>Enables basic movement for particles. (\"Basic\" in the sense of <i>fundamental</i> rather than simplistic.)</p>
<p>It's not a bad idea to always add Movement Basic to new effects; if it ends up being spatially static later, you can remove the Operator for a tiny performance gain.</p>"
		"Element.C_OP_RenderSprites"		"Sprite Renderer"
		"Element.C_OP_RenderSprites:help"		"<p>Renders single- and multiple-frame sprites.</p>

<p>Multi-frame sequences can be animated or used to provide visual variation.</p>

<p>render_sprites is the workhorse renderer, and the one you're likely to be using most of the time.</p>"
		"Element.C_OP_RenderTrails"		"Sprite Trail Renderer"
		"Element.C_OP_RenderTrails:help"		"<p>Trails are sprites with additional built-in behavior that stretches them based on their speed over time.</p>
<p>Traditional use cases for trails include bullet tracers and sparks. Advanced users may also find them useful when particles need to be oriented in 3D space (a case that regular sprites handle poorly.)</p>"
		"Element.C_OP_RenderRopes"		"Rope Renderer"
		"Element.C_OP_RenderRopes:help"		"<p>Ropes (which were named in a simpler time) are sequences of sprites streched across a set of points. Textures intended for use on rope particles are often tiled along one axis so they can be used to create long, thin, curved forms in 3D space.</p>
<p>Ropes can be difficult to work with, but are surprisingly powerful and versatile.</p>"
		"Element.C_INIT_CreateWithinSphere"		"Position Within Sphere Random"
		"Element.C_INIT_CreateWithinSphere:help"		"<p>Randomly spawns a particle within a sphere that's centered on the specified control point.</p>"
		"Element.C_INIT_CreateWithinBox"		"Position Within Box Random"
		"Element.C_INIT_CreateWithinBox:help"		"<p>Randomly spawns a particle within the specified volume.</p>"
		"Element.C_OP_ContinuousEmitter"		"Continuous Emitter"
		"Element.C_OP_ContinuousEmitter:help"		"<p>Emits particles at the specified rate over time. By default, this emitter will continue to emit forever.</p>"
		"Element.C_OP_InstantaneousEmitter"		"Instantaneous Emitter"
		"Element.C_OP_InstantaneousEmitter:help"		"<p>Emits the specified number of particles all at once and never repeats.</p>"
		"Element.C_INIT_RandomLifeTime"		"Lifetime Random"
		"Element.C_INIT_RandomLifeTime:help"		"<p>Defines the lifetime of each particle in seconds, chosen randomly, between <b>lifetime_min</b> and <b>lifetime_max</b>.</p>"
		"Element.C_INIT_PositionPlaceOnGround"		"Position Modify Place On Ground"
		"Element.C_INIT_PositionPlaceOnGround:help"		"<p>\"Snaps\" each particle to the ground (or a specified offset above the ground.)</p>
<p>Note that this operator only searches for ground BELOW its current position - if the particle is already below the ground, it won't snap to the ground above. If there's any doubt, simply add a Position Modify Offset Random initializer above this one in the initializer stack.</p>"
		"Element.C_INIT_RandomAlpha"		"Alpha Random"
		"Element.C_INIT_RandomAlpha:help"		"<p>Particles will be created with a random alpha value within the specified range (0-255).</p>"
		"Element.C_INIT_RandomScalar"		"Scalar Random"
		"Element.C_INIT_RandomScalar:help"		"<p>Allows any exposed scalar (such as radius, alpha, lifetime, etc.) to be initialized with a random value within the specified range.</p>"
		"Element.C_INIT_RemapScalar"		"Remap Initial Scalar"
		"Element.C_INIT_RemapScalar:help"		"<p>Remaps any exposed scalar's initial value to any other scalar.</p>"
		"Element.C_OP_RemapScalar"		"Remap Scalar"
		"Element.C_OP_RemapScalar:help"		"<p>Remaps any exposed scalar's value to any other scalar on an ongoing basis.</p>"
		"Element.C_OP_FadeInSimple"		"Alpha Fade In Simple"
		"Element.C_OP_FadeInSimple:help"		"<p>Fades particles in over time.</p>
<p><b>proportional fade in time</b> is a percentage of the particle's lifetime, expressed as a range between 0 and 1. (So a setting of 0.5 on a particle with a 4-second lifetime would take 2 seconds to fade in completely.)</p>"
		"Element.C_OP_FadeOutSimple"		"Alpha Fade Out Simple"
		"Element.C_OP_FadeOutSimple:help"		"<p>Fades particles out over time.</p>
<p><b>proportional fade out time</b> is a percentage of the particle's lifetime, expressed as a range between 0 and 1. (So a setting of 0.25 on a particle with a 4-second lifetime would start fading out 3 seconds after being emitted, and would take 1 second to fade out completely.)</p>"
		"Element.C_OP_AttractToControlPoint"		"Pull Towards Control Point"
		"Element.C_OP_AttractToControlPoint:help"		"<p>Pulls particles toward the specified control point.</p>
<p>Can also be used to repel particles - simply use negative values for <b>amount of force</b>."
		"Attribute.CParticleSystemDefinition.m_nMaxParticles"		"Maximum Particles"
		"Attribute.CParticleSystemDefinition.m_nMaxParticles:help"		"<p>The maximum number of individual particles that can exist at any time for this system. Any attempts to emit additional particles beyond this maximum will fail.</p>
<p>The particle engine reserves memory for this maximum, so set this as low as you can once you've finished working on your effect.</p>
<p><em>Note that this setting is specific to <b>this effect</b> - any child effects will use their own <b>max_particles</b> setting.</em></p>"
		"Attribute.CParticleSystemDefinition.m_flConstantLifespan"		"Lifetime"
		"Attribute.CParticleSystemDefinition.m_flConstantLifespan:help"		"<p>The amount of time, in seconds, that each particle will exist before being destroyed.</p>"
		"Attribute.CParticleSystemDefinition.m_nInitialParticles"		"Initial Particles"
		"Attribute.CParticleSystemDefinition.m_nInitialParticles:help"		"<p>Number of additional particles that should be emitted the moment the effect is created, independent of any emitter operators.</p>"
		"Attribute.CParticleSystemDefinition.m_ConstantNormal"		"Normal"
		"Attribute.CParticleSystemDefinition.m_ConstantNormal:help"		"<p>Particle <a href=\"https://en.wikipedia.org/wiki/Normal_(geometry)\">normal</a> alignment. Values range between 0 and 1.</p>
<p>For most effects this should remain unchanged from its default (0,0,1).</p>
<p>This field is ignored unless the <b>orientation_type</b> property in the effect's renderer is set to \"Particle Normal Align\" or \"Screen & Particle Normal Align\".</p>"
		"Element.C_OP_WorldTraceConstraint"		"Collision Via Traces"
		"Element.C_OP_WorldTraceConstraint:help"		"<p>Allows particles to collide with scene geometry.</p>

<p><b>USE SPARINGLY!</b> Per-particle collision is one of the most expensive effects operations performance-wise. Also, make sure you always replace the <b>collision group</b> property \"NONE\" with \"DEBRIS\"."
		"Element.C_OP_MaintainEmitter"		"Emit to Maintain Count"
		"Element.C_OP_MaintainEmitter:help"		"<p>Emits particles until it reaches the specified <b>count to maintain</b>, and then stops. Whenever particles are destroyed (by whatever means), the emitter will kick in again to bring the count back up to the max.</p>"
		"Element.C_INIT_RandomRadius"		"Radius Random"
		"Element.C_INIT_RandomRadius:help"		"<p>Initializes each particle with a random radius within the specified range.</p>"
		"Element.C_INIT_RandomColor"		"Color Random"
		"Element.C_INIT_RandomColor:help"		"<p>Initializes each particle with a random color within the specified range.</p>"
		"Element.C_OP_DistanceCull"		"Cull When Crossing Sphere"
		"Element.C_OP_DistanceCull:help"		"<p>Instantly destroys particles when they pass the specified spherical threshold.</p>"
		"Attribute.C_OP_InstantaneousEmitter.m_flStartTime:help"		"Time at which to begin emitting particles (seconds)."
		"Attribute.C_OP_InstantaneousEmitter.m_nParticlesToEmit:help"		"Number of particles to emit in a burst."
		"Attribute.C_OP_InstantaneousEmitter.m_nMinParticlesToEmit:help"		"<p>The minimum number of particles to emit in a burst. Any value other than -1 will tell the system to randomly emit a number of particles between this value and the num_to_emit value.</p>"
		"Attribute.C_OP_InstantaneousEmitter.m_nMaxEmittedPerFrame:help"		"<p>The maximum number of particles to emit per frame.</p>
<p>For example, if the game is running at 30 frames per second and this value is set to 1, then 30 particles will be emitted in one second. Keep in mind that even though the particles are emitted at a different time, they will all die together at the same time. Therefore, if lifetime random is set to 2, then every particle regardless of when it was created will be removed after 2 seconds of the system's lifetime.</p>"
		"Attribute.C_OP_ContinuousEmitter.m_flStartTime"		"Start Time"
		"Attribute.C_OP_ContinuousEmitter.m_flStartTime:shorthelp"		"Time to begin emission."
		"Attribute.C_OP_ContinuousEmitter.m_flStartTime:help"		"Time at which to begin emitting particles (seconds)."
		"Attribute.C_OP_ContinuousEmitter.m_flEmitRate"		"Emission Rate"
		"Attribute.C_OP_ContinuousEmitter.m_flEmitRate:shorthelp"		"Particles to spawn per second."
		"Attribute.C_OP_ContinuousEmitter.m_flEmitRate:help"		"Number of particles to spawn (per second)."
		"Attribute.C_OP_ContinuousEmitter.m_flEmissionDuration"		"Duration"
		"Attribute.C_OP_ContinuousEmitter.m_flEmissionDuration:shorthelp"		"Time to emit in seconds."
		"Attribute.C_OP_ContinuousEmitter.m_flEmissionDuration:help"		"Length of time to continue emitting particles (seconds)."
		"Element.C_INIT_SequenceLifeTime:help"		"<p>Sets a particle's lifespan based on the animation length of the sequence based at the given framerate. Used when a single particle type consists of many sequences with varying sequence lengths (some have 10 frames, others 60, but all must act appropriately without slow framerate, etc.)</p>
<p><i>Note:</i> If the 'use animation rate as FPS' flag of Render_Animated_Sprites has the same FPS settings, a particle will map it lifespan and animation together perfectly.</p>"
		"Attribute.C_INIT_SequenceLifeTime.m_flFramerate:help"		"Sets the desired FPS for the animation. This is mapped to lifespan according to the number of frames in the sequence the particle receives via a <b>sequence_random</b> or other sequence-defining initializer."
		"Element.C_INIT_AgeNoise"		"Lifetime Pre-Age Noise"
		"Element.C_INIT_AgeNoise:help"		"Treats a particle as if it has already spent part of its lifespan. All operators that test particle lifespan will act appropriately."
		"Attribute.C_INIT_AgeNoise.m_flNoiseScale:help"		"This sets the scale of the time part of the noise function - based on particle spawn time. Larger numbers will appear increasingly random, while very small numbers will map to a similar area of the noise and look very similar."
		"Attribute.C_INIT_AgeNoise.m_flNoiseScaleLoc:help"		"This sets the scale of the spatial part of the noise function - based on particle spawn location. Larger numbers will appear increasingly random, while very small numbers will map to a similar area of the noise and look very similar. Time noise is added to spatial noise, so set one or the other to zero in order to receive no effect from that portion of the function."
		"Attribute.C_INIT_AgeNoise.m_vecOffsetLoc:help"		"This sets the offset on the noise function to draw from. Essentially moves the result of a given spatial input to a different seed."
		"Attribute.C_INIT_AgeNoise.m_bAbsVal:help"		"Noise returns -1 to 1 which is mapped to the output range. Using absolute value bool (0/1) , the output can have sudden shifts in direction as the number approaches zero and then bounces back into positives instead of going into negatives."
		"Attribute.C_INIT_AgeNoise.m_bAbsValInv:help"		"Essentially flips the curve created by using the absolute value flag. So instead of getting sharp valleys, you get sharp peaks. The math is 1 minus the absolute value of the noise."
		"Element.C_INIT_MoveBetweenPoints"		"Move Particles Between 2 Control Points"
		"Element.C_INIT_MoveBetweenPoints:help"		"<p>Moves the particles between 2 control points at a value between the minimum and maximum speed. Can be extremely useful for particle tracers, laser sights/beams, and Halo-esque sniper-rifle trails.</p>
<p><i>Note:</i> Normally, this initializer moves particles to the end control point and leaves them there (i.e., if new particles are created, they will spawn at the end control point and immediately vanish). To get around this, add a \"Position Along Path Sequential\" initializer with start and end control points of 0 ABOVE the \"Move Particles Between 2 Control Points\" entry.</p>"
		"Attribute.C_INIT_MoveBetweenPoints.m_flStartOffset:help"		"Offset of where the particles start relative to the starting control point and direction of movement."
		"Attribute.C_INIT_MoveBetweenPoints.m_flEndOffset:help"		"The spread of the particles relative to the end control point. Think of this as how spray works with a gun."
		"Element.C_INIT_PositionOffset"		"Position Modify Offset Random"
		"Element.C_INIT_PositionOffset:help"		"Moves the initial position of a particle in world or local space relative to its emission point.</p>
<p>Generally used in combination with other Position initializers. For example, it can be used to emit particles along a line while still using parts of a sphere emitter.</p>"
		"Attribute.C_INIT_PositionOffset.m_bLocalCoords:help"		"This bool (0/1) sets where to use world or local (emitter) space to do the offset."
		"Attribute.C_INIT_PositionOffset.m_bProportional:help"		"This bool (0/1) sets whether to treat the offset values as an amount relative to the particle's radius. For example, if the offset is set to 0 0 1, and two particles have a radii of 32 and 64, they'd be moved vertically 32 and 64 units respectively."
		"Element.C_INIT_PositionWarp:help"		"<p>Warps the initial position of a particle in world or local space relative to its emission point. Can be used to stretch initial emission shapes. A sphere can be stretched into an ovoid, or smashed.</p>
<p>Useful in addition to sphere emissions distance bias and absolute value to create squashed domes, rings (the elongated ring seen in Portal), etc. Warped particles' initial speed is also warped by the corresponding amount. So particles that are stretched will have a higher initial velocity, while those that are squashed will have lower.</p>"
		"Attribute.C_INIT_PositionWarp.m_flWarpTime:help"		"Treats the min/max as start and end sizes for a warp that takes place over the specified time. So the emission placement of each new particle will be warped over time."
		"Attribute.C_INIT_PositionWarp.m_bInvertWarp:help"		"In the case of a warp transition, it will make it run backwards (max to min)."
		"Attribute.C_INIT_CreateWithinSphere.m_fRadiusMin:help"		"Minimum distance to spawn from the center of the sphere."
		"Attribute.C_INIT_CreateWithinSphere.m_fRadiusMax:help"		"Maximum distance to spawn from the center of the sphere."
		"Attribute.C_INIT_CreateWithinSphere.m_vecDistanceBias:help"		"A bias to the distribution of particles in the system in X Y Z relative to each axis. 1 1 0 will create particles only in the X Y plane, while 1 1 10 will create roughly 10 times as many particles near the top and bottom of the sphere as on the X Y parts. Useful for creating discs, rings, and polar effects."
		"Attribute.C_INIT_CreateWithinSphere.m_vecDistanceBiasAbs:help"		"Setting any axis to one will eliminate particles from one hemisphere of the distribution. Can be used to create hemispheres, quarter spheres, etc. Use wil distance bias to alter the effect. Use negative values in distance bias to flip the hemisphere from one side to the other."
		"Attribute.C_INIT_CreateWithinSphere.m_fSpeedMin:help"		"Minimum initial speed of the particle emitted outward from the sphere."
		"Attribute.C_INIT_CreateWithinSphere.m_fSpeedMax:help"		"Maximum initial speed of the particle emitted outward from the sphere."
		"Attribute.C_INIT_CreateWithinSphere.m_fSpeedRandExp:help"		"The exponent which determines the biasing of particles towards one end or the other of the random range."
		"Attribute.C_INIT_CreateWithinSphere.m_LocalCoordinateSystemSpeedMin:help"		"Local space minimum initial speed of the particle in x y z."
		"Attribute.C_INIT_CreateWithinSphere.m_LocalCoordinateSystemSpeedMax:help"		"Local space maximum initial speed of the particle in x y z."
		"Element.C_INIT_CreationNoise"		"Remap Noise to Scalar"
		"Element.C_INIT_CreationNoise:help"		"Allows any scalar parameter to be initialized to a select range via a noise function. The noise function is mapped based on both time and space, each with their own coordinate scales and offsets. This creates a range of results that are non-random but vary based on creation time and position."
		"Attribute.C_INIT_CreationNoise.m_flNoiseScale:help"		"This sets the scale of the time part of the noise function - based on particle spawn time. Larger numbers will appear increasingly random, while very small numbers will map to a similar area of the noise and look very similar."
		"Attribute.C_INIT_CreationNoise.m_flNoiseScaleLoc:help"		"This sets the scale of the spatial part of the noise function - based on particle spawn location. Larger numbers will appear increasingly random, while very small numbers will map to a similar area of the noise and look very similar. Time noise is added to spatial noise, so set one or the other to zero in order to receive no effect from that portion of the function."
		"Attribute.C_INIT_CreationNoise.m_nFieldOutput:help"		"The scalar to set the initial value on. Radius, Roll, Alpha, Life Duration, etc."
		"Attribute.C_INIT_CreationNoise.m_flOffset:help"		"This sets the offset on the noise function to draw from. Two initial scalar noise functions set to different outputs (say alpha and radius) set to the same coordinate scales will behave the same. Offsets allow for the same scale mapping, but at a different part of the noise. So for example all small radius particles may have a high alpha rather than a low one if the offset is used."
		"Attribute.C_INIT_CreationNoise.m_vecOffsetLoc:help"		"This sets the offset on the noise function to draw from. Two initial scalar noise functions set to different outputs (say alpha and radius) set to the same coordinate scales will behave the same. Offsets allow for the same scale mapping, but at a different part of the noise. So for example all small radius particles may have a high alpha rather than a low one if the offset is used."
		"Attribute.C_INIT_CreationNoise.m_bAbsVal:help"		"Noise returns -1 to 1 which is mapped to the output range. Using absolute value bool (0/1) , the output can have sudden shifts in direction as the number approaches zero and then bounces back into positives instead of going into negatives."
		"Attribute.C_INIT_CreationNoise.m_bAbsValInv:help"		"Essentially flips the curve created by using the absolute value flag. So instead of getting sharp valleys, you get sharp peaks. The math is 1 minus the absolute value of the noise."
		"Element.C_INIT_RandomSequence"		"Sequence Random"
		"Element.C_INIT_RandomSequence:help"		"When using a multi-frame texture, this allows particles to randomly start at a minimum and maximum supplied frame."
		"Element.C_INIT_InitialVelocityNoise"		"Velocity Noise"
		"Element.C_INIT_InitialVelocityNoise:help"		"Allows particle velocity to be initialized to a select range via a noise function. The noise function is mapped based on both time and space, each with their own coordinate scales and offsets. This creates a range of results that are non-random but vary based on creation time and position."
		"Element.C_OP_PositionLock"		"Movement Lock to Control Point"
		"Element.C_OP_PositionLock:help"		"Causes particles to inherit the movement (and optionally rotation) of a control point."
		"Element.C_OP_DampenToCP"		"Movement Dampen Relative to Control Point"
		"Element.C_OP_DampenToCP:help"		"<p>Drains a particle's internal velocity as it approaches the specified control point. If no other forces are acting on it, the particle will eventually stop.</p>
<p>This can be used with operator \"Movement Lock to Control Point\" (and its distance fade property) to have a control point \"capture\" particles near it then draw them along. It can also lock endpoints of a line of particles while allowing the middle section to move freely.</p>"
		"Element.C_OP_VelocityMatchingForce"		"Movement Match Particle Velocities"
		"Element.C_OP_VelocityMatchingForce:help"		"Forces particles to inherit the velocity of the first one emitted. Can copy the recorded value to a control point."
		"Element.C_OP_InterpolateRadius"		"Radius Scale"
		"Element.C_OP_InterpolateRadius:help"		"<p>Scales particles from the start to end scale over the specified time. Multiple Radius Scale operators can be used in an effect as long as their time coverage doesn't overlap.</p>"
		"Element.C_OP_SpinUpdate"		"Rotation Basic"
		"Element.C_OP_SpinUpdate:help"		"<p>This simply enables rotation through the effect's Base Properties (<b>rotation_speed</b>) or through the initializer \"Rotation Speed Random\".</p>
<p>Particle rotation can also be achieved with the operators \"Rotation Spin Roll\" and \"Rotation Spin Yaw\", which do not require the \"Rotation Basic\" operator.</p>"
		"Element.C_INIT_RandomRotation"		"Rotation Random"
		"Element.C_INIT_RandomRotation:help"		"<p>Randomly picks an initial rotation value for each particle within the specified range. The axis is chosen through the <b>rotation field</b> property.</p>
<p><b><i>NOTE</i></b>: The properties <b>yaw_offset_min</b> and <b>yaw_offset_max</b> are mis-named at the time of this writing. They should instead read \"rotation min\" and \"rotation max\" - these define the range.</p>"
		"Attribute.CBaseRendererSource2.m_hTexture"		"Texture"
		"Attribute.CBaseRendererSource2.m_hTexture:help"		"<p>The source texture to be applied to each particle. Eligible files use the extension *.vtex.</p>"
		"Attribute.CParticleSystemDefinition.m_bViewModelEffect"		"View Model Effect"
		"Attribute.CParticleSystemDefinition.m_bViewModelEffect:help"		"Used for effects that are attached to player weapons/hands in first-person games."
		"Attribute.CParticleSystemDefinition.m_bScreenSpaceEffect"		"Screen Space Effect"
		"Attribute.CParticleSystemDefinition.m_bScreenSpaceEffect:help"		"Tells the effect to render in screen space (on the picture plane) rather than in world space."
		"Attribute.CParticleSystemDefinition.m_flConstantRadius"		"Radius"
		"Attribute.CParticleSystemDefinition.m_flConstantRadius:help"		"<p>Radius for each particle, in world units.</p>"
		"Attribute.CParticleSystemDefinition.m_ConstantColor"		"Color"
		"Attribute.CParticleSystemDefinition.m_ConstantColor:help"		"Base color tint for each particle."
		"Element.ParticleChildrenInfo_t"		"Child Effect"
		"Element.ParticleChildrenInfo_t:help"		"<p>Any effect can be a child of any other effect (with the exception of infinitely-recursive hierarchies.)</p>
<p>Hierarchies are useful for keeping effects organized. They can also promote efficient reuse and modularity of effects. Furthermore, when combined with advanced parent-to-child control point passing, hierarchies become an extremely powerful tool.</p>"
		"Attribute.ParticleChildrenInfo_t.m_flDelay"		"Delay"
		"Attribute.ParticleChildrenInfo_t.m_flDelay:help"		"Delay time, in seconds, before the child effect is triggered."
		"Attribute.ParticleChildrenInfo_t.m_bEndCap"		"End Cap Effect"
		"Attribute.ParticleChildrenInfo_t.m_bEndCap:help"		"<p>End cap effects are triggered <i>when the parent effect is destroyed</i>.</p>
<p>So, for example, a projectile effect might have an explosion as its child - when set as an end cap, the explosion will play automatically when the projectile is destroyed (i.e. when it hits its target.)</p>"
		"Attribute.ParticleChildrenInfo_t.m_bDisableChild"		"Disable Child Effect"
		"Attribute.ParticleChildrenInfo_t.m_bDisableChild:help"		"<p>A quick way to hide a child effect without having to remove it completely.</p>"
		"Element.C_OP_ConstrainDistance"		"Constrain Distance to Control Point"
		"Element.C_OP_ConstrainDistance:help"		"<p>Locks particles's positions to a specified radial range from a control point.</p>"
		"Attribute.CParticleOperatorInstance.m_bDisableOperator"		"Disable"
		"Attribute.CParticleOperatorInstance.m_bDisableOperator:help"		"Allows temporary disabling of operators without having to remove them completely."
		"Attribute.CBaseRendererSource2.m_flSelfIllumAmount"		"Self-Illumination Amount"
		"Attribute.CBaseRendererSource2.m_flSelfIllumAmount:help"		"<p>The degree to which the <i>unlit</i> texture color adds to the lighting calculation.</p>
<p>The easiest way to think of it is as an ambient lighting value for the particle system. So 0.0 will result in a diffuse lit particle. 0.5 will result in a diffuse lit particle but with an added ambient lighting value of 0.5.</p>"
		"Attribute.CBaseRendererSource2.m_bAdditive"		"Use Additive Blending"
		"Attribute.CBaseRendererSource2.m_bAdditive:help"		"<p>Toggles whether particles will <a href=\"https://en.wikipedia.org/wiki/Additive_color\">blend additively</a>.</p>"
		"Attribute.CBaseRendererSource2.m_flDiffuseAmount"		"Diffuse Lighting Amount"
		"Attribute.CBaseRendererSource2.m_flDiffuseAmount:help"		"<p>Degree to which particles will receive scene lighting, with 0 being completely unlit (dark).</p>"
		"Element.C_OP_RenderProjected"		"Projected Texture Renderer"
		"Element.C_OP_RenderProjected:help"		"<p>Renders projected textures, which are capable of certain behaviors that are otherwise difficult to achieve.</p>
<p>Take, for example, a large scorch-mark on the ground. If you used a flat sprite (even one oriented to the ground polygon on which it sat), it still wouldn't look right if it crossed polygon boundaries that changed angles or elevation. A projected texture, however, will conform to the surfaces upon which it's projected.</p>
<p><i>Note that unlike many other effect renderers, this one takes a VMAT rather than a VTEX. VMATs are authored in the Material Editor, and should be shader type \"Projected Dota\".</i></p>"
		"Element.C_OP_RenderDeferredLight"		"Deferred Light Renderer"
		"Element.C_OP_RenderDeferredLight:help"		"<p>Renders one or more real-time (but not shadow-casting) light sources based on particle positions.</p>"
		"Element.C_OP_SetControlPointPositions"		"Set Control Point Positions"
		"Element.C_OP_SetControlPointPositions:help"		"<p>Allows the manual positioning of up to four control points.</p>
<p>If you're only setting one CP, consider using \"Set Single Control Point Position\" instead.</p>"
		"Element.C_OP_SetSingleControlPointPosition"		"Set Single Control Point Position"
		"Element.C_OP_SetSingleControlPointPosition:help"		"<p>Allows the manual positioning of a single control point.</p>"
		"Element.C_INIT_CreateSequentialPath"		"Position Along Path Sequential"
		"Element.C_INIT_CreateSequentialPath:help"		"<p>Initializes particle positions sequentially along a line between two control points.</p>"
		"Element.C_INIT_CreateAlongPath"		"Position Along Path Random"
		"Element.C_INIT_CreateAlongPath:help"		"<p>Initializes particle positions randomly along a line between two control points.</p>"
		"Element.C_OP_RandomForce"		"Random Force"
		"Element.C_OP_RandomForce:help"		"<p>Generates a random force within the specified range that's applied uniformly to all particles within the effect.</p>"
		"Element.C_OP_ForceBasedOnDistanceToPlane"		"Force Based on Distance from Plane"
		"Element.C_OP_ForceBasedOnDistanceToPlane:help"		"<p>Applies a force to each particle based on its distance from a specified plane. (You can think of this as simply remapping a distance to a force range.)</p>"
		"Element.C_INIT_CreateInEpitrochoid"		"Position Along Epitrochoid"
		"Element.C_INIT_CreateInEpitrochoid:help"		"<p>Initializes particle positions within an <a href=\"https://en.wikipedia.org/wiki/Epitrochoid\">epitrochoid</a>.</p>
<p>Notably, this position initializer can be used to modify another position initializer if <b>offset from existing position</b> is checked. With the right combination of position initializers and epitrochoid settings, you can achieve positional noise with more coherence than simple random ranges offer.</p>"
		"Element.C_INIT_RingWave"		"Position Along Ring"
		"Element.C_INIT_RingWave:help"		"<p>Initializes particle positions along a whole or partial ring.</p>
<p>Like \"Position Within Sphere Random\", this initializer has additional functionality that can impart radial force to particles via <b>min initial speed</b> and <b>max initial speed</b>.</p>"
		"Element.C_INIT_RemapScalarToVector"		"Remap Scalar to Vector"
		"Element.C_INIT_RemapScalarToVector:help"		"<p>Upon particle initialization, remap any starting scalar (alpha, radius, etc.) to any starting vector (position, color, etc.)</p>"
		"Element.C_OP_Cull"		"Cull Random"
		"Element.C_OP_Cull:help"		"<p>Randomly destroys <b>Cull Percentage</b> of existing particles in the effect between <b>Cull Start Time</b> and <b>Cull End Time</b>.</p>"
		"Element.C_OP_SetControlPointToCenter"		"Set Control Point to Particles' Center"
		"Element.C_OP_SetControlPointToCenter:help"		"<p>Finds the centroid of all particles in the effect and sets the specified control point to that position.</p>
<p><i>Note that this takes place on the effect level, rather than per-particle.</i></p>"
		"Element.C_INIT_RemapSpeedToScalar"		"Remap Speed to Scalar"
		"Element.C_INIT_RemapSpeedToScalar:help"		"<p>Remaps either a control point's speed (effect-level) or each particle's speed (particle-level) to a scalar value.</p>"
		"Element.C_OP_ColorInterpolate"		"Color Fade"
		"Element.C_OP_ColorInterpolate:help"		"<p>Within the specified time, each particle fades from its color at <b>fade_start_time</b> to <b>color_fade</b>.</p>"
		"Element.C_OP_VectorNoise"		"Noise Vector"
		"Element.C_OP_VectorNoise:help"		"<p>Remaps a noise function to any exposed vector. The noise function is mapped based on both time and space, each with their own coordinate scales and offsets.</p>
<p>This creates a range of results that are non-random but vary based on creation time and position.</p>"
		"Element.C_OP_Noise"		"Noise Scalar"
		"Element.C_OP_Noise:help"		"<p>Remaps a noise function to any exposed scalar. The noise function is mapped based on both time and space, each with their own coordinate scales and offsets.</p>
<p>This creates a range of results that are non-random but vary based on creation time and position.</p>"
		"Element.C_OP_InheritFromParentParticles"		"Inherit Attribute from Parent Particle"
		"Element.C_OP_InheritFromParentParticles:help"		"<p>Assigns a parent particle's attribute to each particle within the system.</p>
<p>This differs from the initializer \"Inherit Initial Value from Parent Particle\" in that the parent's attribute will be inherited every frame in real-time.</p>"
		"Element.C_INIT_InheritFromParentParticles"		"Inherit Initial Value from Parent Particle"
		"Element.C_INIT_InheritFromParentParticles:help"		"<p>Assigns a parent particle's attribute to each particle's initial value for that attribute.</p>
<p>This differs from the operator \"Inherit Attribute from Parent Particle\" in that it runs only once, on particle initialization.</p>"
		"Element.C_OP_ClampScalar"		"Clamp Scalar"
		"Element.C_OP_ClampScalar:help"		"<p>Limits the specified scalar's value to a range between <b>output minimum</b> and <b>output maximum</b>.</p>"
		"Element.C_OP_ClampVector"		"Clamp Vector"
		"Element.C_OP_ClampVector:help"		"<p>Limits the specified vector's value to a range between <b>output minimum</b> and <b>output maximum</b>.</p>"
		"Element.C_OP_Spin"		"Rotation Spin Roll"
		"Element.C_OP_Spin:help"		"<p>Rotates each particle along the \"roll\" axis.</p>"
		"Element.C_OP_SpinYaw"		"Rotation Spin Yaw"
		"Element.C_OP_SpinYaw:help"		"<p>Rotates each particle along the \"yaw\" axis.</p>"
		"Element.C_OP_FadeIn"		"Alpha Fade In Random"
		"Element.C_OP_FadeIn:help"		"<p>Fades particles in over a random period of time within the specified range.</p>
<p>Unlike \"Alpha Fade In Simple\", this operator has an option to define your range in seconds rather than a percentage of the particle's lifespan. To use seconds, simply turn the <b>proportional</b> property off.</p>"
		"Element.C_OP_FadeOut"		"Alpha Fade Out Random"
		"Element.C_OP_FadeOut:help"		"<p>Fades particles out over a random period of time within the specified range.</p>
<p>Unlike \"Alpha Fade Out Simple\", this operator has an option to define your range in seconds rather than a percentage of the particle's lifespan. To use seconds, simply turn the <b>proportional</b> property off.</p>"
		"Element.C_OP_FadeAndKill"		"Alpha Fade and Decay"
		"Element.C_OP_FadeAndKill:help"		"<p>Essentially combines the three operators \"Lifespan Decay\", \"Alpha Fade In Simple\", and \"Alpha Fade Out Simple\".</p>"
		"Element.C_OP_PlaneCull"		"Cull When Crossing Plane"
		"Element.C_OP_PlaneCull:help"		"<p>Instantly destroys particles when they pass the specified plane.</p>"
		"Element.C_OP_SetControlPointToImpactPoint"		"Set Control Point to Impact Point"
		"Attribute.CParticleOperatorInstance.m_flOpStartFadeInTime"		"Operator Fade: Operator Start Fadein"
		"Attribute.CParticleOperatorInstance.m_flOpStartFadeInTime:help"		"<h2>Operator Fade Group</h2>
<p>The properties of the operator fade group enable you to hand-tune exactly when you want an operator to influence your effect. These are standard properties that work on all operators. Depending on the operator, the fade component may or may not function - binary operators that can't logically scale (such as setting control point positions) will ignore fades and simply switch on and off.</p>
<p>Operator fade times are relative to the <i>emitter lifespan</i>, so an operator that fades in after 3 seconds does so relative to the emitters life, not the individual particle.</p>
<p>If an oscillation time is set, fade in and fade out times become 0.0 to 1.0 times relative to that oscillation time. If you wish your operator to oscillate in and out, setting an oscillation time of 4, a fade in of .25 and a fade out of .75 would mean that the operator has no effect for 1 second (one quarter the oscillation cycle time), works for 2 seconds (.25-.75), fades back out at 3 (three quarters of the oscillation cycle time), and then the cycle loops at the 4th second back to the start.</p>
<p><i>Note: The operator fade group is generally considered to be an advanced tool, and is often used only as a last resort in cases where operator-specific control mechanisms are (for whatever reason) proving unsuitable.</i></p>"
		"Attribute.CParticleOperatorInstance.m_flOpEndFadeInTime"		"Operator Fade: Operator End Fadein"
		"Attribute.CParticleOperatorInstance.m_flOpEndFadeInTime:help"		"<h2>Operator Fade Group</h2>
<p>The properties of the operator fade group enable you to hand-tune exactly when you want an operator to influence your effect. These are standard properties that work on all operators. Depending on the operator, the fade component may or may not function - binary operators that can't logically scale (such as setting control point positions) will ignore fades and simply switch on and off.</p>
<p>Operator fade times are relative to the <i>emitter lifespan</i>, so an operator that fades in after 3 seconds does so relative to the emitters life, not the individual particle.</p>
<p>If an oscillation time is set, fade in and fade out times become 0.0 to 1.0 times relative to that oscillation time. If you wish your operator to oscillate in and out, setting an oscillation time of 4, a fade in of .25 and a fade out of .75 would mean that the operator has no effect for 1 second (one quarter the oscillation cycle time), works for 2 seconds (.25-.75), fades back out at 3 (three quarters of the oscillation cycle time), and then the cycle loops at the 4th second back to the start.</p>
<p><i>Note: The operator fade group is generally considered to be an advanced tool, and is often used only as a last resort in cases where operator-specific control mechanisms are (for whatever reason) proving unsuitable.</i></p>"
		"Attribute.CParticleOperatorInstance.m_flOpStartFadeOutTime"		"Operator Fade: Operator Start Fadeout"
		"Attribute.CParticleOperatorInstance.m_flOpStartFadeOutTime:help"		"<h2>Operator Fade Group</h2>
<p>The properties of the operator fade group enable you to hand-tune exactly when you want an operator to influence your effect. These are standard properties that work on all operators. Depending on the operator, the fade component may or may not function - binary operators that can't logically scale (such as setting control point positions) will ignore fades and simply switch on and off.</p>
<p>Operator fade times are relative to the <i>emitter lifespan</i>, so an operator that fades in after 3 seconds does so relative to the emitters life, not the individual particle.</p>
<p>If an oscillation time is set, fade in and fade out times become 0.0 to 1.0 times relative to that oscillation time. If you wish your operator to oscillate in and out, setting an oscillation time of 4, a fade in of .25 and a fade out of .75 would mean that the operator has no effect for 1 second (one quarter the oscillation cycle time), works for 2 seconds (.25-.75), fades back out at 3 (three quarters of the oscillation cycle time), and then the cycle loops at the 4th second back to the start.</p>
<p><i>Note: The operator fade group is generally considered to be an advanced tool, and is often used only as a last resort in cases where operator-specific control mechanisms are (for whatever reason) proving unsuitable.</i></p>"
		"Attribute.CParticleOperatorInstance.m_flOpEndFadeOutTime"		"Operator Fade: Operator End Fadeout"
		"Attribute.CParticleOperatorInstance.m_flOpEndFadeOutTime:help"		"<h2>Operator Fade Group</h2>
<p>The properties of the operator fade group enable you to hand-tune exactly when you want an operator to influence your effect. These are standard properties that work on all operators. Depending on the operator, the fade component may or may not function - binary operators that can't logically scale (such as setting control point positions) will ignore fades and simply switch on and off.</p>
<p>Operator fade times are relative to the <i>emitter lifespan</i>, so an operator that fades in after 3 seconds does so relative to the emitters life, not the individual particle.</p>
<p>If an oscillation time is set, fade in and fade out times become 0.0 to 1.0 times relative to that oscillation time. If you wish your operator to oscillate in and out, setting an oscillation time of 4, a fade in of .25 and a fade out of .75 would mean that the operator has no effect for 1 second (one quarter the oscillation cycle time), works for 2 seconds (.25-.75), fades back out at 3 (three quarters of the oscillation cycle time), and then the cycle loops at the 4th second back to the start.</p>
<p><i>Note: The operator fade group is generally considered to be an advanced tool, and is often used only as a last resort in cases where operator-specific control mechanisms are (for whatever reason) proving unsuitable.</i></p>"
		"Attribute.CParticleOperatorInstance.m_flOpFadeOscillatePeriod"		"Operator Fade: Operator Fade Oscillate"
		"Attribute.CParticleOperatorInstance.m_flOpFadeOscillatePeriod:help"		"<h2>Operator Fade Group</h2>
<p>The properties of the operator fade group enable you to hand-tune exactly when you want an operator to influence your effect. These are standard properties that work on all operators. Depending on the operator, the fade component may or may not function - binary operators that can't logically scale (such as setting control point positions) will ignore fades and simply switch on and off.</p>
<p>Operator fade times are relative to the <i>emitter lifespan</i>, so an operator that fades in after 3 seconds does so relative to the emitters life, not the individual particle.</p>
<p>If an oscillation time is set, fade in and fade out times become 0.0 to 1.0 times relative to that oscillation time. If you wish your operator to oscillate in and out, setting an oscillation time of 4, a fade in of .25 and a fade out of .75 would mean that the operator has no effect for 1 second (one quarter the oscillation cycle time), works for 2 seconds (.25-.75), fades back out at 3 (three quarters of the oscillation cycle time), and then the cycle loops at the 4th second back to the start.</p>
<p><i>Note: The operator fade group is generally considered to be an advanced tool, and is often used only as a last resort in cases where operator-specific control mechanisms are (for whatever reason) proving unsuitable.</i></p>"
		"Attribute.CParticleSystemDefinition.m_nMinGPULevel"		"Minimum GPU Level"
		"Attribute.CParticleSystemDefinition.m_nMinGPULevel:help"		"This property relies on settings in a game config file, and is best left alone."
		"Attribute.CParticleSystemDefinition.m_nMinCPULevel"		"Minimum CPU Level"
		"Attribute.CParticleSystemDefinition.m_nMinCPULevel:help"		"This property relies on settings in a game config file, and is best left alone."
		"Attribute.C_OP_RenderSprites.m_flDepthBias:help"		"Offsets particle depth via the shader. This is more expensive than per particle offsets which can be achieved by using \"visibility camera depth bias\""
		"Attribute.CParticleVisibilityInputs.m_flCameraBias:help"		"Offsets per particle depth from camera. This is cheaper than \"depth comparison bias\" which offsets particle render depth via the shader."
		"Attribute.CParticleSystemDefinition.m_flCullRadius:help"		"Any other value is hardcoded;
0 Use PArticle Bounds;
-1  Disables Fog of war and is always on;
-2  Do not shrink bounds;"
		"Attribute.CParticleOperatorInstance.m_nOpEndCapState:help"		"<b>-1</b> -> Operate while alive and for endcap (default)
<br> 
<b>0 </b> -> Operate while alive
<br>
<b>1 </b> -> Operate for end cap"
		"Attribute.C_INIT_RingWave.m_flParticlesPerOrbit:help"		"This along with turning on \"even distribution\" will evenly space the particles around the ring using X particles"
		"Attribute.C_INIT_RingWave.m_bEvenDistribution:help"		"Enabling even distribution will evenly space the particles around the ring."
		"Attribute.C_OP_CurlNoiseForce.m_vecOffsetRate:help"		"This will increment the noise offset each frame"
		"Attribute.C_OP_CurlNoiseForce.m_vecNoiseScale:help"		"Amplitude of the noise"
		"Attribute.C_OP_CurlNoiseForce.m_useCurl:help"		"toggle between dnoise() and curlnoise()"
		"Element.C_OP_CalculateVectorAttribute:help"		"This lets you specify up to 2 vector attributes (with weights), and up to two control points (with offsets and weights), plus an initial value and a final scale (both vectors). It then does this calculation:

<blockquote>Output_attribute = final scale * ( start value + inputscale1*inputfield1 + inputscale2*inputfield2 + controlpoint1*controlpointscale1 + controlpoint2 * controlpoint2scale);</blockquote>
     
(Then, If the output attribute is \"particle normal\", it will normalize it).<br><br>


This has many uses, and can mix attributes together, normalize attributes, scale them, offset them, etc."
		"Element.C_OP_MovementPlaceOnGround:help"		"if ( m_nRefCP1 > -1 )
{
	if ( ( pParticles->GetControlPointAtCurrentTime( m_nRefCP1 ) - pCtx->m_vecPrevPos1 ).Length() > m_flTolerance )
	{
		bDirty = true;
		pCtx->m_vecPrevPos1 = pParticles->GetControlPointAtCurrentTime( m_nRefCP1 );
		pCtx->m_flLerpTime = pParticles->m_flCurTime;
	}
}"
		"Element.C_OP_RemapCPOrientationToRotations:help"		"Two New Options: <br>

<b>Use Quoternions Internally :</b><br> will use the Control points Matrix to extract Quoternion Rotations and apply that to the Orientation of the Particle. 
<br>
<br>
<b>Write Normal instead of Rotation :</b><br> is a sub section of Use Quaternion and will extract the CP Quoternion Fwd (X) Direction and map it to the Particle Normal. 
<br><br>
While Off operator will work as before."
		"Attribute.C_OP_RenderStandardLight.m_flFalloffLinearity"		"Falloff Linearity"
		"Attribute.C_OP_RenderStandardLight.m_flFalloffLinearity:help"		"0.0 = quadratic falloff (harsher)
1.0 = linear falloff (softer)"
		"Attribute.C_OP_WorldTraceConstraint.m_nCollisionMode"		"Collision Modes"
		"Attribute.C_OP_WorldTraceConstraint.m_nCollisionMode:help"		"Collision Modes :<p>

Per-Particle Trace - Does a trace every frame for each particle.  Most accurate, but very expensive.  Avoid if possible.<p>

Trace Caching - Builds up a trace cache each time it does a trace and similar nearby particles will use the same data.  Less accurate, but faster than constant tracing.<p>

Per-Frame Plane Set - Creates a set of planes from trace tests and only evaluates versus those planes.  Can lead to false positives/negatives, but cheap for a lot of particles.<p>

Initial Trace Down - Does a single trace down and creates a plane versus the impact point.  All particles collide versus that plane.  Very cheap, but often wrong unless you know the location the effect is authored for.<p>

Collision Disabled - No collision at all.  This operation is aborted.<p>"
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_nChildGroupID:help"		"Children with this Group ID specified will not fire when the system is created.

Instead, they will fire based on the settings of this operator.  Group ID is available under the Base Properties as an Advanced Option of all particle systems."
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_flClusterRefireTimeMin:help"		"This is the minimum time before random firings of a child.

Children are selected randomly from any systems which match the Group ID and are not currently in-progress.  Once a child has finished, it will once again be available to fire.  To have multiple concurrent children of the same type, add multiple identicle children.

Because the children are of an unknownable lifespan with each firing, sequential firing is not predictable, so it will always be random amongst available children.

If more specific control is needed, multiple operators with multiple Group ID's can be used."
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_flClusterRefireTimeMax:help"		"This is the maximum time before random firings of a child.

Children are selected randomly from any systems which match the Group ID and are not currently in-progress.  Once a child has finished, it will once again be available to fire.  To have multiple concurrent children of the same type, add multiple identicle children.

Because the children are of an unknownable lifespan with each firing, sequential firing is not predictable, so it will always be random amongst available children.

If more specific control is needed, multiple operators with multiple Group ID's can be used."
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_nClusterSizeMin:help"		"This is the minimum number of children to fire before triggering a cooldown period.

The operator will pick a count each time it starts a cluster and fire that many children before cooling down for the specified period."
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_nClusterSizeMax:help"		"This is the maximum number of children to fire before triggering a cooldown period.

The operator will pick a count each time it starts a cluster and fire that many children before cooling down for the specified period."
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_flClusterCooldownMin:help"		"This is the minimum amount of time to cooldown after a cluster has fired.

When the specified number of children have fired, the operator will cooldown for this long before triggering additional children."
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_flClusterCooldownMax:help"		"This is the maximum amount of time to cooldown after a cluster has fired.

When the specified number of children have fired, the operator will cooldown for this long before triggering additional children."
		"Attribute.CParticleFunction.m_nOpEndCapState"		"EndCap State"
		"Attribute.CParticleFunction.m_nOpEndCapState:shorthelp"		"Does this particle alway run or only during normal time or only during endcap?"
		"Attribute.CParticleFunction.m_nOpEndCapState:help"		"-1 Lifestate and endcap state 
0 During alive state of particle system
1 During dead state of particle system"
		"Attribute.CBaseRendererSource2.m_nFeatheringMode:help"		"Activates Depth Feathering. On (If Possible) will always draw the system even if feathering isn't available. On (Required) will suppress the system rendering if feathering isn't available."
		"Attribute.C_INIT_CreateOnGrid.m_nXCount"		"X Dimension Count"
		"Attribute.C_INIT_CreateOnGrid.m_nXCount:shorthelp"		"This is the number of particles to place along the X Dimension of the grid."
		"Attribute.C_INIT_CreateOnGrid.m_nXCount:help"		"This is the number of particles to place along the X Dimension of the grid.

Minimum will be clamped to one."
		"Attribute.C_INIT_CreateOnGrid.m_nYCount"		"Y Dimension Count"
		"Attribute.C_INIT_CreateOnGrid.m_nYCount:shorthelp"		"This is the number of particles to place along the Y Dimension of the grid."
		"Attribute.C_INIT_CreateOnGrid.m_nYCount:help"		"This is the number of particles to place along the Y Dimension of the grid.

Minimum will be clamped to one."
		"Attribute.C_INIT_CreateOnGrid.m_nZCount"		"Z Dimension Count"
		"Attribute.C_INIT_CreateOnGrid.m_nZCount:shorthelp"		"This is the number of particles to place along the Z Dimension of the grid."
		"Attribute.C_INIT_CreateOnGrid.m_nZCount:help"		"This is the number of particles to place along the Z Dimension of the grid.

Minimum will be clamped to one."
		"Attribute.C_INIT_CreateOnGrid.m_nYSpacing"		"Y Dimension Spacing"
		"Attribute.C_INIT_CreateOnGrid.m_nYSpacing:shorthelp"		"This is the disteance in units to place between each particle on the Y Dimension."
		"Attribute.C_INIT_CreateOnGrid.m_nYSpacing:help"		"This is the disteance in units to place between each particle on the Y Dimension."
		"Attribute.C_INIT_CreateOnGrid.m_nZSpacing"		"Z Dimension Spacing"
		"Attribute.C_INIT_CreateOnGrid.m_nZSpacing:shorthelp"		"This is the disteance in units to place between each particle on the Z Dimension."
		"Attribute.C_INIT_CreateOnGrid.m_nZSpacing:help"		"This is the disteance in units to place between each particle on the Z Dimension."
		"Attribute.C_INIT_CreateOnGrid.m_nControlPointNumber"		"Control Point Number"
		"Attribute.C_INIT_CreateOnGrid.m_nControlPointNumber:help"		"The control point to be used when placing the particles in space.
Can be in local space with respect to this control point, or world space depending on settings.
Will also be placed centered around thsi control point, or moving outward, based on settings."
		"Attribute.C_INIT_CreateOnGrid.m_bLocalSpace"		"Use Local Space"
		"Attribute.C_INIT_CreateOnGrid.m_bLocalSpace:shorthelp"		"Use Local Space of Control Point or World Space"
		"Attribute.C_INIT_CreateOnGrid.m_bLocalSpace:help"		"If set, particles will be placed in local space of the control point.

Otherwise, they'll be in world-space."
		"Attribute.C_INIT_CreateOnGrid.m_bCenter"		"Center Around Control Point"
		"Attribute.C_INIT_CreateOnGrid.m_bCenter:shorthelp"		"Center around CP or have CP act as a corner"
		"Attribute.C_INIT_CreateOnGrid.m_bCenter:help"		"If set, particles will be centered around the control point.

Otherwise, the control point will act as the starting corner."
		"Attribute.C_INIT_CreateOnGrid.m_bHollow"		"Hollow"
		"Attribute.C_INIT_CreateOnGrid.m_bHollow:shorthelp"		"Create a solid grid or a hollow grid (only edges/faces)"
		"Attribute.C_INIT_CreateOnGrid.m_bHollow:help"		"If set, particles will not be created in the center of the grid.

For three dimensions, this means a hollow box will be created.
For two dimesion (1 for any dimension count), a rectangular border will be created."
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nCP"		"Control Point Number"
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nCP:shorthelp"		"Which CP to use for particle rotation"
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nCP:help"		"This operator is intended for sprite based renderers.  It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation.

This field is for the referenced control point."
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nFieldOutput"		"Rotation Field"
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nFieldOutput:shorthelp"		"Which particle rotation to set relative to the control point."
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nFieldOutput:help"		"This operator is intended for sprite based renderers.  It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation.

This field is for the rotation you wish to set on the sprites."
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_flOffsetRot"		"Offset Rotation"
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_flOffsetRot:shorthelp"		"The offset for the particle rotation from the control point rotation in degrees."
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_flOffsetRot:help"		"This operator is intended for sprite based renderers.  It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation.

This field allows an offset to be set, so if the CP is at 90 degrees, but you want the sprite to be 180, you can put 90 here."
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nComponent"		"Control Point Axis"
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nComponent:shorthelp"		"The axis of the control point to use for rotation - use particle preview CP rotation to test."
		"Attribute.C_INIT_RemapInitialCPDirectionToRotation.m_nComponent:help"		"This operator is intended for sprite based renderers.  It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation.

This is the control point axis you wish to drive the sprite rotation.
You can check the particle preview panel and the X/Y/Z value specified there is the same here.  So if you set the Z component, then the value shown in the particle preview for rotation on Z should be what is set on the sprite's rotation."
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nCP"		"Control Point Number"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nCP:shorthelp"		"Control Point to reference for rotation"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nCP:help"		"This operator is intended for sprite based renderers. It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation. This field is for the referenced control point."
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nFieldOutput"		"Rotation Field"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nFieldOutput:shorthelp"		"Rotation value to change on particle"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nFieldOutput:help"		"This operator is intended for sprite based renderers. It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation. This field is for the rotation you wish to set on the sprites."
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_flOffsetRot"		"Offset of Rotation"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_flOffsetRot:shorthelp"		"How much to offset particles rotation for CP's rotation in degrees"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_flOffsetRot:help"		"This operator is intended for sprite based renderers. It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation. 

<b>This field allows an offset to be set, so if the CP is at 90 degrees, but you want the sprite to be 180, you can put 90 here.</b>"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nComponent"		"Control Point Axis"
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nComponent:shorthelp"		"The axis to use for particle rotation - use particle preview to test."
		"Attribute.C_OP_RemapControlPointOrientationToRotation.m_nComponent:help"		"This operator is intended for sprite based renderers. It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation. 
<b>This is the control point axis you wish to drive the sprite rotation. You can check the particle preview panel and the X/Y/Z value specified there is the same here. So if you set the Z component, then the value shown in the particle preview for rotation on Z should be what is set on the sprite's rotation.</b>"
		"Attribute.C_OP_LerpToInitialPosition.m_nControlPointNumber"		"Control Point Number"
		"Attribute.C_OP_LerpToInitialPosition.m_nControlPointNumber:shorthelp"		"Initial Position Reference CP"
		"Attribute.C_OP_LerpToInitialPosition.m_nControlPointNumber:help"		"This operator will interpolate particles into the same position relative to a control point that they were initialized in.

The interpolation factor will determine how fast/strong the effect is.

<b>This field is the control point that is specified for the relative position.</b>"
		"Attribute.C_OP_LerpToInitialPosition.m_flInterpolation"		"Interpolation Amount"
		"Attribute.C_OP_LerpToInitialPosition.m_flInterpolation:shorthelp"		"How strong is this interpolation to the initial position?"
		"Attribute.C_OP_LerpToInitialPosition.m_flInterpolation:help"		"This operator will interpolate particles into the same position relative to a control point that they were initialized in.

<b>The interpolation factor will determine how fast/strong the effect is.  This can be mapped to a curve or control point to modify this value.</b>"
		"Attribute.CParticleFunction.m_bDisableOperator"		"Disable Operator"
		"Attribute.CParticleFunction.m_bDisableOperator:shorthelp"		"This will turn off the operator."
		"Attribute.CParticleFunction.m_bDisableOperator:help"		"Disabling the operator will completely remove it from functioning.  Useful for testing."
		"Attribute.CParticleFunction.m_Notes"		"Notes"
		"Attribute.CParticleFunction.m_Notes:shorthelp"		"Add comments here"
		"Attribute.CParticleFunction.m_Notes:help"		"If you have comments for the specific usage of this operator in this system, add them here and they'll be saved with the system."
		"Attribute.C_INIT_CreateOnGrid.m_nXSpacing"		"X Dimension Spacing"
		"Attribute.C_INIT_CreateOnGrid.m_nXSpacing:shorthelp"		"This is the disteance in units to place between each particle on the X Dimension."
		"Attribute.C_INIT_CreateOnGrid.m_nXSpacing:help"		"This is the disteance in units to place between each particle on the X Dimension."
		"Element.C_INIT_CreateOnGrid"		"Position On Grid"
		"Element.C_INIT_CreateOnGrid:shorthelp"		"Creates particles along a X/Y/Z grid as with specified count/spacing"
		"Element.C_INIT_CreateOnGrid:help"		"This creates particles along an X/Y/Z grid as specified.  

If using a single dimension count for one dimension, it will be a 2D plane.

If setting hollow, 2D borders or hollow cubes can be created.

The spacing and dimension count can be set to random ranges or controlled via control point as well."
		"Element.C_INIT_RemapInitialCPDirectionToRotation"		"Remap Control Point Orientation to Rotation"
		"Element.C_INIT_RemapInitialCPDirectionToRotation:shorthelp"		"Remap CP orientation axis to particle sprite rotation axis"
		"Element.C_INIT_RemapInitialCPDirectionToRotation:help"		"This operator is intended for sprite based renderers.  It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation."
		"Element.C_OP_RemapControlPointOrientationToRotation"		"Remap Control Point Orientation to Rotation"
		"Element.C_OP_RemapControlPointOrientationToRotation:shorthelp"		"Remap CP orientation axis to particle sprite rotation axis"
		"Element.C_OP_RemapControlPointOrientationToRotation:help"		"This operator is intended for sprite based renderers.  It will take the specified Control Points orientation along an axis and set the specified sprite rotation to the same rotation."
		"Element.C_OP_LerpToInitialPosition"		"Lerp To Initial Position"
		"Element.C_OP_LerpToInitialPosition:shorthelp"		"Interpolates particles back to their starting point."
		"Element.C_OP_LerpToInitialPosition:help"		"This operator moves particles back to their starting point relative to a control point.  It interpolates them, so the strength of the move (and inversely, how much other forces can move them) can be modulated by lifespan/curve/random range/whatever.  

For example they can fly off into space, then reassemble themselves over time into their original pattern.  The original position can be anything  a position within sphere, grid, ring, snapshot, etc."
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_flClusterSize:help"		"Number of children to fire before entering cooldown"
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_flClusterRefireTime:help"		"Time/RandRange/Etc. for firing off children"
		"Attribute.C_OP_RepeatedTriggerChildGroup.m_flClusterCooldown:help"		"Cooldown between clusters of firings"
		"Element.C_INIT_CreateSequentialPathV2"		"Position Along Path Sequential"
		"Element.C_INIT_CreateSequentialPathV2:help"		"<p>Initializes particle positions sequentially along a line between two or more control points.</p>"
		"Attribute.C_OP_RemapSpeedtoCP.m_bUseDeltaV"		"Use Delta of Velocity"
		"Attribute.C_OP_RemapSpeedtoCP.m_bUseDeltaV:shorthelp"		"If set, this will use changes in velocity, instead of the current velocity to determine the output"
		"Attribute.C_OP_RemapSpeedtoCP.m_bUseDeltaV:help"		"If set, this will use changes in velocity, instead of the current velocity to determine the output.

This means when movement starts, stops, or change speed/direction, the input will change.  But if it is moving at a constant velocity, the delta of velocity will be zero."
		"Attribute.C_OP_RenderSprites.m_nOrientationType"		"Orientation Type"
		"Attribute.C_OP_RenderSprites.m_nOrientationType:help"		"Full 3-Axis Rotation: Must be used in conjuction with a \"Remap CP orientation to rotations\" and a \"Movement lock to control point\" with lock rotations on"
		"Element.C_OP_PinParticleToCP:help"		"This takes a specific particle and locks it to a control point and sets its force scale to 0.  This can be used with a Rope Spring Contraint to pin desired points.  The pin can be broken by a number of different methods including distance to neighboring particles, distance to control point/s, or speed.  Any number of pins can be added to lock specific particles."
		"Element.C_OP_PerParticleForce"		"Per-Particle Force"
		"Element.C_OP_PerParticleForce:help"		"This force allows a local or world space force to be applied with a force scale that's a float evaluator.  It allows for per-particle based acceleration forces using the float evaluator."
		"Element.C_OP_RopeSpringConstraint:help"		"This is a spring constraint intended for ropes of a static particle count.  This is intended for systems of around 5 - 32 particles in length.  Fewer particles will tend to work better than more.  The resting length is based on its spawn/initialization position, as such instantaneous systems work best.  However, you can manually set the reseting length spacing if desired, which will override the initial spacing - this also better allows for adding segments over time.  Minimum and Maximum Segement Length is based off of percentages of the resting length.  High scale factor for spring correction will make the springs stiffer, but also cause the springs to break down.  This can be compensated to a small degree with the maximum time step of the system."
		"Attribute.C_OP_RopeSpringConstraint.m_flMinDistance"		"Minimum Segment Length %"
		"Attribute.C_OP_RopeSpringConstraint.m_flMinDistance:help"		"The segment length between any two particles will try to remain at least this long (a percentage relative to the spacing it had upon creation)."
		"Attribute.C_OP_RopeSpringConstraint.m_flMaxDistance"		"Maximum Segment Length %"
		"Attribute.C_OP_RopeSpringConstraint.m_flMaxDistance:help"		"The segment length between any two particles will try to remain at most this long (a percentage relative to the spacing it had upon creation)."
		"Attribute.C_OP_RopeSpringConstraint.m_flAdjustmentScale"		"Scale Factor for Spring Correction"
		"Attribute.C_OP_RopeSpringConstraint.m_flAdjustmentScale:help"		"This is how much to scale the amount of work the spring does trying to maintain it's segment length.  Larger numbers will enforce the lengths more effectively, but make the system more unstable.  Upping the systems Maximum Time Step can help to compensate for instability at the cost of performance (use with caution!)."
		"Attribute.C_OP_RopeSpringConstraint.m_flRestLength"		"Slack"
		"Attribute.C_OP_RopeSpringConstraint.m_flRestLength:help"		"This is the amount of slack in the system relative to its starting position.  Larger numbers will be looser, while smaller numbers will be tighter."
		"Attribute.C_OP_PerParticleForce.m_flForceScale"		"Force Scale"
		"Attribute.C_OP_PerParticleForce.m_flForceScale:help"		"This allows the force applied per-particle to be scaled as desired."
		"Attribute.C_OP_PerParticleForce.m_vForce"		"Force to Apply"
		"Attribute.C_OP_PerParticleForce.m_vForce:help"		"The amount of force in X/Y/Z to apply."
		"Attribute.C_OP_PerParticleForce.m_nCP"		"Local Space Control Point"
		"Attribute.C_OP_PerParticleForce.m_nCP:help"		"If specified, this will be the control point used for localized force direction."
		"Attribute.C_OP_PinParticleToCP.m_nControlPointNumber"		"Control Point Number"
		"Attribute.C_OP_PinParticleToCP.m_nControlPointNumber:help"		"This is the control point to lock to."
		"Attribute.C_OP_PinParticleToCP.m_vecOffset"		"Offset"
		"Attribute.C_OP_PinParticleToCP.m_vecOffset:help"		"An offset from the control point can be specified."
		"Attribute.C_OP_PinParticleToCP.m_bOffsetLocal"		"Offset in Local Space"
		"Attribute.C_OP_PinParticleToCP.m_bOffsetLocal:help"		"If selected, the control point used will offset in its local space."
		"Attribute.C_OP_PinParticleToCP.m_nParticleSelection"		"Particle to use"
		"Attribute.C_OP_PinParticleToCP.m_nParticleSelection:help"		"Which particle should we pin?"
		"Attribute.C_OP_PinParticleToCP.m_nParticleNumber"		"Particle Number"
		"Attribute.C_OP_PinParticleToCP.m_nParticleNumber:help"		"If Particle to Use is set to Specified Particle Number, then use this to set the desired particle number."
		"Attribute.C_OP_PinParticleToCP.m_nPinBreakType"		"Pin Break Type"
		"Attribute.C_OP_PinParticleToCP.m_nPinBreakType:help"		"If this pin should break when under forces, this is where it should be set.<br><br>
<br>
\"Don't Break\" - Always Pin, Don't Break.<br><br>
\"Distance to Neighboring Particle\" - Distance to the next particle, can break more easily if particles stretch very rapidly. <br><br>
\"Distance to Farthest Particle\" - Distance to the farthest particle, either the first or the last depending on where this particle is in the sequence.<br><br>
\"Distance to First Particle\" - Distance to the first particle.<br><br>
\"Distance to Last Particle\" - Distance to the last particle.<br><br>
\"Distance to Particle System Center\" - Distance to the Particle System's Center - note that as this particle is moved, by consequence of it moving, the center will also shift in its direction.<br><br>
\"Distance to Control Point\" - Distance to a specified Control Point (Comparison Control Point 1)<br><br>
\"Distance to Either of Two Control Points\" - Distance to two control points - if either one exceeds the specified distance, the pin will break.<br><br>
\"Distance to Both of Two Control Points\" - Distance to two control points - both must be farther than the specified distance for the pin to break.<br><br>
\"Break Speed\" - if the pin moves faster than this, it will break."
		"Attribute.C_OP_PinParticleToCP.m_flBreakDistance"		"Break Length %"
		"Attribute.C_OP_PinParticleToCP.m_flBreakDistance:help"		"This is the length, based in a percentage versus the initial creation length, at which to break relative to the selected option."
		"Attribute.C_OP_PinParticleToCP.m_flBreakSpeed"		"Break Speed"
		"Attribute.C_OP_PinParticleToCP.m_flBreakSpeed:help"		"The speed of the pin's movement at which to break.  This only is applied in Break Speed is selected as the break type."
		"Attribute.C_OP_PinParticleToCP.m_nBreakControlPointNumber"		"Break Comparison Control Point 1"
		"Attribute.C_OP_PinParticleToCP.m_nBreakControlPointNumber:help"		"If any control point break type is specified, this control point is used to determine the distance."
		"Attribute.C_OP_PinParticleToCP.m_nBreakControlPointNumber2:help"		"Used if either of the following is selected for Break Type : <br>
Distance to Either of Two Control Points
 Points<br>
Distance to Both of Two Control Points<br>

The distance from the selected pin to both control points will be used in this case."
		"Attribute.C_OP_RopeSpringConstraint.m_flInitialRestingLength"		"Manual Resting Length Spacing"
		"Attribute.C_OP_RopeSpringConstraint.m_flInitialRestingLength:shorthelp"		"The resting length distance between any two particles. -1.0 == automatic distance from initial position"
		"Attribute.C_OP_RopeSpringConstraint.m_flInitialRestingLength:help"		"This is the distance between any two particles when in a resting state.  By default (-1.0) this value is determined automatically by the initial state of the system and the average spacing between each particle.  However, it can be set manually to allow for both known setups that differ from the initial spacing, or dynamic systems that add particles over time or need to change the resting length."
		"Attribute.C_OP_Decay.m_bRopeDecay"		"Reduce Rope Popping"
		"Attribute.C_OP_Decay.m_bRopeDecay:shorthelp"		"This helps fading/scaling out rope particles from popping when they die."
		"Attribute.C_OP_Decay.m_bRopeDecay:help"		"This helps fading/scaling out rope particles from popping when they die.

When a rope segment is killed, the next in the rope chain can't draw to a now non-existent neighbor.  Because of this, you can have popping when killing rope particles.

Enabling this option will keep those particles around until their neighbor is also ready to die so that there is no pop in the rendering.  

You should always use fading/scaling to make use of this feature, and max particle counts need to take these extra phantom particles into account."
		"Attribute.C_OP_LerpToInitialPosition.m_flScale"		"Scale"
		"Attribute.C_OP_LerpToInitialPosition.m_flScale:shorthelp"		"Scale all particle positions relative to the specified control point"
		"Attribute.C_OP_LerpToInitialPosition.m_flScale:help"		"Particles' position will be scaled to a relative position from the specified control point based on their initial position."
		"Attribute.C_OP_InstantaneousEmitter.m_nSnapshotControlPoint"		"Control Point with snapshot data"
		"Attribute.C_OP_InstantaneousEmitter.m_nSnapshotControlPoint:help"		"If set, the emission amount will be controlled by the specified snapshot.
<p>
This will instantly emit as many particles as are contained within the snapshot.
<p>
Optionally, if creation times are specified within the snapshot, particles will be created at the specified creation times, plus any start time.  Creation times must be in linear order within the snapshot for this to function properly."
		"Attribute.C_OP_RenderCables.m_flTextureRepeatsPerSegment"		"Number of repetitions along the path"
		"Attribute.C_OP_RenderCables.m_flTextureRepeatsPerSegment:help"		"Specifies the number of times the texture will repeat between particles or along the entire path depending on the texture repetition mode."
		"Attribute.C_OP_RenderCables.m_flTextureRepeatsCircumference"		"Repetitions around cable"
		"Attribute.C_OP_RenderCables.m_flTextureRepeatsCircumference:help"		"Specifies the number of times the texture will repeat around the circumference of the cable."
		"Attribute.C_OP_RenderCables.m_flColorMapOffsetU"		"Color map offset around cable"
		"Attribute.C_OP_RenderCables.m_flColorMapOffsetU:help"		"Offset to apply to the starting position of the color map around the circumference of the cable. "
		"Attribute.C_OP_RenderCables.m_flColorMapOffsetV"		"Color map offset along path"
		"Attribute.C_OP_RenderCables.m_flColorMapOffsetV:help"		"Offset to apply to the starting position of the color map along the length of the path."
		"Attribute.C_OP_RenderCables.m_flNormalMapOffsetU"		"Normal map offset around cable"
		"Attribute.C_OP_RenderCables.m_flNormalMapOffsetU:help"		"Offset to apply to the starting position of the normal map around the circumference of the cable. "
		"Attribute.C_OP_RenderCables.m_flNormalMapOffsetV"		"Normal map offset along path"
		"Attribute.C_OP_RenderCables.m_flNormalMapOffsetV:help"		"Offset to apply to the starting position of the normal map along the length of the path."
		"Attribute.C_OP_RenderCables.m_flTessScale"		"Tessellation scale factor"
		"Attribute.C_OP_RenderCables.m_flTessScale:help"		"Multiplier which can be used to increase or decrease the number of triangles used when rendering the cable. A higher number will increase the number of triangles used and a lower number will decrease the number of triangles used."
		"Attribute.C_OP_RenderCables.m_nMinTesselation"		"Minimum number of steps between particles"
		"Attribute.C_OP_RenderCables.m_nMinTesselation:help"		"Minimum number of steps that will be used to draw a segment of the cable between two particles regardless of the size of the cable on screen. The actual number of steps is drawn is always a power of 2, if a non-power of 2 value is specified, the actual number of steps will by rounded down to a power of 2."
		"Attribute.C_OP_RenderCables.m_nMaxTesselation"		"Maximum number of steps between particles"
		"Attribute.C_OP_RenderCables.m_nMaxTesselation:help"		"Maximum number of steps to be used to draw a segment between two particles. If a non-power of 2 value is specified the number of steps drawn will be rounded down to a power of 2."
		"Attribute.C_OP_RenderCables.m_nTextureRepetitionMode"		"Texture repetition mode"
		"Attribute.C_OP_RenderCables.m_nTextureRepetitionMode:help"		"Controls wether the number of texture repetitions is specified per-particle or for the entire length of the path."
		"Attribute.C_OP_RenderCables.m_bDrawCableCaps"		"Draw cable end caps"
		"Attribute.C_OP_RenderCables.m_bDrawCableCaps:help"		"Enable drawing of cap geometry on the ends of the cable."
		"Attribute.C_OP_RenderCables.m_flCapRoundness"		"Cable end cap shape factor"
		"Attribute.C_OP_RenderCables.m_flCapRoundness:help"		"Value which controls the shape of the end caps. Range is [ 0, 2 ] where 0 = pointed, 1 = spherical, and 2 = rounded square."
		"Attribute.C_OP_RenderCables.m_flCapOffsetAmount"		"Cable end cap offset amount"
		"Attribute.C_OP_RenderCables.m_flCapOffsetAmount:help"		"Controls how far the end cap extends past the end of the cable. This is multiplier on the radius, so if the value is 1 the distance the is equal to the radius. Valid range is [ 0, 2 ]."
		"Element.C_OP_EndCapTimedFreeze"		"Endcap timed system freeze"
		"Element.C_OP_EndCapTimedFreeze:shorthelp"		"freezes the simulation of a system on playing the endcap"
		"Element.C_OP_EndCapTimedFreeze:help"		"<p>This will freeze simulation of the system after a time upon playing the endcap.</p>

<p>Because the system will no longer simulate, this is a one-way operation short of game-code killing the effect.</p>

<p>It is intended for an effect that may become a static part of the level upon ending.</p>

<p>Reference System :
<a href='asset:particles/testsystems/test_endcap_freeze.vpcf'>Test Timed Freeze</a>

</p>"
		"Element.C_OP_RemapCrossProductOfTwoVectorsToVector:shorthelp"		"Performs a cross product on two vectors"
		"Element.C_OP_RemapCrossProductOfTwoVectorsToVector:help"		"This operator performs a cross product operation on two input vectors.

As these vectors are evaluators, this can be existing particle vector fields, CP values, orientations, etc.

The output can be normalized.



<p>Reference System :</p>
<p>Shows a normal being set to the cross product of the direction to a control point (the center of a ring) and the direction to the next particle on that ring.</p>
<p>
<a href='asset:particles/testsystems/test_cross_product.vpcf'>Test Cross Product</a>
</p>"
		"Element.C_OP_RenderVRHapticEvent"		"Render VR Haptic Event"
		"Element.C_OP_RenderVRHapticEvent:shorthelp"		"Plays haptics to a players hands"
		"Element.C_OP_RenderVRHapticEvent:help"		"Each particle is interpreted as an amplitude to be sent to the haptics every frame.

Expected amplitude is a normalized 0.0 - 1.0 range."
		"Attribute.C_OP_RenderVRHapticEvent.m_nHand"		"hatpic hand"
		"Attribute.C_OP_RenderVRHapticEvent.m_nHand:shorthelp"		"which hand to send the haptics to"
		"Attribute.C_OP_RenderVRHapticEvent.m_nHand:help"		"When specified via control point is selected, the control point field contains the hand number.
<p>
0 = left<p>
1 = right<p>
<p>
When Detect from CP's Object is used, the CP that is selected is checked for the users hand and if found, it is set to the hand assigned to that CP.  This allows a single effect to be played to either hand and it will select the right one automatically.  
<p>
If no hand is found, no haptics will be created."
		"Attribute.C_OP_RenderCables.m_nRoundness"		"Roundness factor"
		"Attribute.C_OP_RenderCables.m_nRoundness:help"		"Controls how many sides the cable generates: 0 = 4, 1 = 8, 2 = 16"
		"Attribute.C_OP_WorldTraceConstraint.m_nCollisionModeMin"		"Minimum Quality Collision Mode"
		"Attribute.C_OP_WorldTraceConstraint.m_nCollisionModeMin:shorthelp"		"The minimum mode to fall back to on lowest settings"
		"Attribute.C_OP_WorldTraceConstraint.m_nCollisionModeMin:help"		"Based on the user's settings, collision may be scaled back to cheaper alternatives.  This allows a minimum level to be set for effects which require some control over that process.  <p>
It is recommended you leave this at Collision Disabled unless you have a good reason not to.<p>

The following modes will be used based on detail levels, clamped to the selected collision mode and minimum collision mode:<p>

Ultra : Per-Particle Trace<br>
High : Trace Caching<br>
Medium : Per-Frame Planeset<br>
Low : Collision Disabled<p>

Initial Trace Down will not be used unless manually selected due to its highly situational nature.<p>

Collision Modes :<p>

Per-Particle Trace - Does a trace every frame for each particle.  Most accurate, but very expensive.  Avoid if possible.<p>

Trace Caching - Builds up a trace cache each time it does a trace and similar nearby particles will use the same data.  Less accurate, but faster than constant tracing.<p>

Per-Frame Plane Set - Creates a set of planes from trace tests and only evaluates versus those planes.  Can lead to false positives/negatives, but cheap for a lot of particles.<p>

Initial Trace Down - Does a single trace down and creates a plane versus the impact point.  All particles collide versus that plane.  Very cheap, but often wrong unless you know the location the effect is authored for.<p>

Collision Disabled - No collision at all.  This operation is aborted.<p>"
		"Attribute.CParticleSystemDefinition.m_flMaximumSimTime:help"		"maximum time to sim before drawing first frame"
		"Attribute.CParticleSystemDefinition.m_flMinimumTimeStep:help"		"for simulating at < frame rate"
		"Attribute.CParticleSystemDefinition.m_nMinimumFrames:help"		"number of frames to apply max/min simulation times"
		"Attribute.C_OP_RenderStandardLight.m_lightCookie:help"		"effect/lightcookies.vtex

electrical"
		"Element.C_OP_SetFloat:name_ref"		"Set Float"
		"Element.C_OP_SetFloat"		"Set Float"
		"Element.C_OP_SetFloat:help"		"Noise is a continuous function based on the input position and time on either a per-particle or a collection control point basis.<p>

Noise Change Rate : Defines how the noise itself will move over time in the X/Y/Z dimensions.  We could have noise that just changes over time without translation if we did 4D noise, but it'd be 33% more expensive, probably not worth it.<p>

Noise Type : There are various types of noise to choose from.  The list is ordered in terms of performance cost, so Classic Perlin Noise is the cheapest.<p>

Noise Frequency : The frequency or scale of the noise.<p>

Noise Offset: The relative position/offset/seed of the starting state of the noise.<p>

Noise Octaves: The noise can be recursively applied to itself at different frequencies as octaves.  Each additional octave carries out the noise function so it's that much more expensive.  2 octaves are 2x the cost of 1, 3 is 3x, 4 is 4x.  Use sparingly.<p>

Noise Turbulence : The output of the noise can be fed through offsets, scales, and functions and fed back into noise.  This produces turbulence in the noise.  Turbulence is runs additional noise, but is roughly like adding a single octave to the noise.  Usually this produces far more interesting effects than octaves and thus is better cost to output.<p>

Turbulence Frequiency Scale :  The turbulence is best run at a different frequency than the primary noise, this allows the input frequency to be scaled.<p>

Turbulence Mix : Defines how the turbulence is combined with the base noise.  It can be overdriven outside the normal ranges and go negative for interesting effects.<p>

Noise Modifier : The resulting noise can be additionally modified through a noise modifier.  This is relatively cheap compared to the noise itself and cheaper than octaves or turbulence.<p>"
		"Attribute.CParticleFunctionEmitter.m_nEmitterIndex:help"		"When the emitter index is not the default value of -1, it can be used to run different initializers for particles emitted by this emitter. This can be used (for instance) to have 2 emitters that emit from different locations, use different tint values, etc.<br><br>When the emitter index is not -1, and the associated emitter index within an initializer is also not -1, that initializer will only run when they match.<br><br>Example: To emit particles of two different tint colors, create two emitters, one with index 0 and one with index 1. Add _2_ \"Color Random\" initializers with different colors, and set the associated emitter index to 0 for 1 of them and 1 for the other. Then, each of the 2 emitters will create particles of different colors."
		"Attribute.CParticleFunctionInitializer.m_nAssociatedEmitterIndex:help"		"The Associated emitter index allows tying an initializer to only run for particles created by an emitter with the same index. This can be used to have multiple emitters, each of which emits particles with different properties (such as position, sequence, tint, lifetime, etc)."
		"Attribute.C_OP_ContinuousEmitter.m_nLimitPerUpdate:help"		"Limit to emitting this many particles per update.  0 is no limit."
		"Attribute.C_OP_ContinuousEmitter.m_bForceEmitOnFirstUpdate:help"		"When set, forces at least one particle to be emitted on the first update."
		"Attribute.C_OP_ContinuousEmitter.m_bForceEmitOnLastUpdate:help"		"When set, forces the emitter to create a final particle on the update it is stopped."
		"Attribute.C_OP_RenderGpuImplicit.m_bUsePerParticleRadius:help"		"Honors per-particle radius when rendering (will be multiplied by radius scale).

Will make rendering more expensive.
Roughly similar radii will be most efficient, avoid vastly different sizes."
		"Attribute.C_OP_RenderGpuImplicit.m_fIsosurfaceThreshold:help"		"Value between 0..1 that determines where the surface is constructed.

Each particle makes a \"field value\": 1.0 in the center, falling off to 0.0 at the radius.  All particles are summed together, and then the surface is drawn where the value is == the isosurface value.

Smaller values will look more blobby (less like lots of spheres).
Small values will also be less efficient to render (there is effectively more empty space where we evaluate the field but won't draw anything)."
		"Attribute.C_OP_RenderGpuImplicit.m_fGridSize:help"		"Spacing of the grid the field functions are evaluated on.

Smaller will quickly increase the cost generating the surface and number of vertices/indices generated."
		"Attribute.C_INIT_CreateOnModel.m_bUseMesh:help"		"Places the particles on randomly chosen points on the renderable mesh surface. You'll need to make sure your mesh has the Keep Vertices In Memory flag set in ModelDoc, or we won't have surface data to use and will fall back to using the hitboxes in that case."
		"Element.C_OP_SetUserEvent:name_ref"		"Set Event"
		"Element.C_OP_SetUserEvent:help"		"This operator allows per-particle events to created and read by children.  Child systems can create and initialize particles based on these events, so they can initialize their positions/colors/radii etc. to the values of the parent particle who created the event.
<p>
Any particle float evaluator value can be used to determine when the event is created, such as a speed or time threshold, a CP value, etc.
<p>
There are two thresholds relative to the output value that will be evaluated and events can be created on both.
<p>
The Rising Edge is the treshold that activates when the value is greater than this value.  After this is activated, no further events will be created for this particle until it falls below the Falling Edge.  If the falling edge has its own event, that will fire when the value goes below it.
<p>
Note that the falling edge will not ever occur until rising edge has occurred."
		"Attribute.C_OP_SetUserEvent.m_flRisingEdge"		"Rising Edge Threshold"
		"Attribute.C_OP_SetUserEvent.m_flRisingEdge:help"		"The Rising Edge is the treshold that activates when the value is greater than this value.  After this is activated, no further events will be created for this particle until it falls below the Falling Edge.  If the falling edge has its own event, that will fire when the value goes below it."
		"Attribute.C_OP_SetUserEvent.m_nRisingEventType"		"Rising Edge Event Type"
		"Attribute.C_OP_SetUserEvent.m_nRisingEventType:help"		"The event that gets created when passing the rising edge threshold."
		"Attribute.C_OP_SetUserEvent.m_flFallingEdge"		"Falling Edge Threshold"
		"Attribute.C_OP_SetUserEvent.m_flFallingEdge:help"		"The Falling Edge Event will fire once the value falls below this value if it was previously active.  
The falling edge will not ever occur until rising edge has occurred.  An event is optional here, but likewise, another Rising Edge event will not be created until a falling edge has occurred."
		"Attribute.C_OP_SetUserEvent.m_nFallingEventType"		"Falling Edge Event Type"
		"Attribute.C_OP_SetUserEvent.m_nFallingEventType:help"		"The event that gets created when passing the falling edge threshold."
		"Attribute.C_OP_ContinuousEmitter.m_nEventType:help"		"This is the type of event which will cause the particle to be emitted."
		"Attribute.C_OP_ContinuousEmitter.m_bInitFromKilledParentParticles:help"		"Particles can be created on events that occur in the parent.  For example, when they die, or collide with the world, or are spawned.  There are also user created events you can manually create on the parent with the Set Event operator."
		"Attribute.C_INIT_InitFromParentKilled.m_nEventType:help"		"What type of event should we be using to initialize this value?"
		"Attribute.C_OP_RenderGpuImplicit.m_nIndexCountKb:help"		"Size of the index buffer required to render this system.
If you see artifacts when rendering, a very small grid is generally the cause.
If you require a very small grid (<b>expensive</b>!), as a backup increase this value -- you can get an estimate of the value required via `r_particle_gpu_implicit_debug_stats 1`"
		"Attribute.C_OP_RenderGpuImplicit.m_nVertexCountKb:help"		"Size of the vertex buffer required to render this system.
If you see artifacts when rendering, a very small grid is generally the cause.
If you require a very small grid (<b>expensive</b>!), as a backup increase this value -- you can get an estimate of the value required via `r_particle_gpu_implicit_debug_stats 1`"
		"Attribute.C_OP_RenderModels.m_nSubModelFieldType:help"		"Controls how the <b>submodel field</b> is used.
<p>
<b>BodyGroup SubModel</b><br>
By default it's the submodel index of the bodygroup specified by bodygroup field.<p>
<b>MeshGroup Index</b><br>
Allows a single meshgroup to be specified, bodygroup field is ignored.<p>
<b>MeshGroup Mask</b><br>
Allows a composite meshgroup mask to be specified, bodygroup field is ignored.<p>
<b>Model Default MeshGroup Mask</b><br>
submodel and bodygroup fields ignored, model gets default meshgroup mask
compiled into model.<p>"
	}
}
