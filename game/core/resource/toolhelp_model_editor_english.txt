"lang"
{
	"Tokens"
	{
		"Element.CVpropDataList:help"		"Edit the data added to the model's prop data here. These are the same fields that existed in Source1's keyvalues block. "
		"Attribute.CVpropDataList.m_nBreakableType:help"		"The type of pieces the model will shatter into. "
		"Attribute.CVpropDataList.m_nBreakableCount:help"		"How many pieces the model shatters into."
		"Attribute.CVpropDataList.m_nBreakableSkin:help"		"Which skin the break piece uses"
		"Attribute.CVpropDataList.m_additional:help"		"Add additional keyvalues here"
		"Attribute.CVpropDataList.m_base:shorthelp"		"Specify a base propdata class to derive from"
		"Attribute.CVpropDataList.m_base:help"		"Specify a base propdata class to derive from (base types can be found in propdata.txt)

<a href='https://intranet.valvesoftware.com/index.php/Prop_Data_(Left_4_Dead)'>Left4 Dead Prop Data</a>"
		"Attribute.CVpropDataList.m_bBlockLOS"		"Block LOS"
		"Attribute.CVpropDataList.m_bBlockLOS:help"		"Override whether this prop should block NPC's Line-Of-Sight."
		"Attribute.CVpropDataList.m_bAIwalkable:help"		"Override whether AI should consider this prop as walkable on."
		"Attribute.CVpropDataList.m_bAllowStatic:help"		" Allow this prop to be static as well as physically simulated."
		"Attribute.CVpropDataList.m_flDmgBullets:shorthelp"		"Mod damage done by bullets to this prop."
		"Attribute.CVpropDataList.m_flDmgBullets:help"		"Mod damage done by bullets to this prop.

NOTE: Use damage modifiers to reflect differences between the amount of
damage that an object takes from different damage types. Don't
use them to reflect overall damage strength. i.e. Stone is resilient
to everything. To reflect this, increase the health of all stone
objects, don't set the damage modifiers lower."
		"Attribute.CVpropDataList.m_flDmgClub:shorthelp"		"Mod damage done by clubs to this prop."
		"Attribute.CVpropDataList.m_flDmgClub:help"		"Mod damage done by clubs to this prop.

NOTE: Use damage modifiers to reflect differences between the amount ofdamage that use them to reflect overall damage strength. i.e. Stone is resilient
to everything. To reflect this, increase the health of all stone
objects, don't set the damage modifiers lower."
		"Attribute.CVpropDataList.m_flDmgExplosive"		"Mod damage done by explosives to this prop."
		"Attribute.CVpropDataList.m_flDmgExplosive:help"		"Mod damage done by explosives to this prop.

NOTE: Use damage modifiers to reflect differences between the amount ofdamage that use them to reflect overall damage strength. i.e. Stone is resilient
to everything. To reflect this, increase the health of all stone
objects, don't set the damage modifiers lower."
		"Attribute.CVpropDataList.m_flDmgFire:shorthelp"		"Mod damage done by fire to this prop."
		"Attribute.CVpropDataList.m_flDmgFire:help"		"Mod damage done by fire to this prop.

NOTE: Use damage modifiers to reflect differences between the amount of
damage that an object takes from different damage types. Don't
use them to reflect overall damage strength. i.e. Stone is resilient
to everything. To reflect this, increase the health of all stone
objects, don't set the damage modifiers lower."
		"Attribute.CVpropDataList.m_damageTable:help"		"Specify a custom physics impact damage table for this prop."
		"Attribute.CVpropDataList.m_nExplosionType:shorthelp"		"(molotov/grenade/fireworks/default)"
		"Attribute.CVpropDataList.m_nExplosionType:help"		"If default, explosive_damage/explosive_radius are used as usual"
		"Attribute.CVpropDataList.m_flExplosiveDamage:shorthelp"		"Explosive damage done by this prop."
		"Attribute.CVpropDataList.m_flExplosiveDamage:help"		"Explosive damage done by this prop.

Radius of the explosion caused by this prop when it breaks.//		NOTE: If radius and damage are specified for a prop, then the prop will automatically create an explosion with the specified values when the prop is broken."
		"Attribute.CVpropDataList.m_flExplosiveRadius:shorthelp"		"Radius of the explosion caused by this prop when it breaks."
		"Attribute.CVpropDataList.m_flExplosiveRadius:help"		"Radius of the explosion caused by this prop when it breaks.//		NOTE: If radius and damage are specified for a prop, then the prop will automatically create an explosion with the specified values when the prop is broken."
		"Attribute.CVpropDataList.m_nMultiplayerBreak:shorthelp"		"Set multiplayer breakable spawn behavior (default/server/client/both)"
		"Attribute.CVpropDataList.m_nMultiplayerBreak:help"		"Set multiplayer breakable spawn behavior (default/server/client/both)<br>

NOTE: if multiplayer_break is \"both\", each piece is spawned by the default dll unless its \"break\" section has a \"multiplayer_break\" key with a value of \"client\" or \"server\".<br>

NOTE: if specifying non-default behavior, the top-level breakable and the breakable pieces need to \"agree\".<br>"
		"Attribute.CVpropDataList.m_nHealth:help"		" Amount of damage this prop should take before breaking."
		"Attribute.CVpropDataList.m_flExplosiveDelay:shorthelp"		"Time before explosion occurs"
		"Attribute.CVpropDataList.m_bGlow:shorthelp"		"Does the prop get a l4d style glow"
		"Attribute.CVpropDataList.m_nPhysicsMode:help"		"Set multiplayer physics behaviour (1=full, 2=non-solid,3=clientside)"
		"Attribute.CVpropDataList.m_physgunInteractions:help"		"Set the physgun_interaction keyvalues here"
		"Element.CVhitBoxSetList:shorthelp"		"HitboxSetList"
		"Element.CVhitBoxSetList:help"		"Hitboxsetlists contain a list of hitbox sets.<br>
To add a new set, right click in the item and select <b>\"Add Hitbox Set\"</b>"
		"Element.CVhitBoxSet:shorthelp"		"Hitbox set"
		"Element.CVhitBoxSet:help"		"Hitbox sets contain a list of hitboxes.<br>
Right click the item to get these menu options:<br>
<b>Auto Populate Set</b>: brings up a menu that allows you to select what joints get a hitbox<br>
Hitboxes are automatically sized based on the skinned vertices.<br>"
		"Attribute.CAuthPhysBody.m_pBreakablePartData"		"Breakable Part Override"
		"Attribute.CAuthPhysBody.m_pBreakablePartData:shorthelp"		"Per-part breakable attributes override"
		"Attribute.CAuthPhysBody.m_pBreakablePartData:help"		"Provides per-body part breakable attributes, e.g. fadeout time can be set to be shorter for smaller insignificant parts of a breakable than for bigger parts."
		"Element.CVModel"		"VMDL"
		"Element.CVModel:help"		"This is the high level content side file that is compliled to generate a game side model ( .vmdl_c ). All data needed for a model is either directly part of or referenced by the vmdl."
		"Element.CVmeshList"		"Mesh List"
		"Element.CVmeshList:help"		"This is a list of meshes that the model contains. Meshes in this list can be referenced by mesh groups, and LOD ( level of detail ) groups."
		"Element.CVmesh"		"VMesh"
		"Element.CVmesh:help"		"This is the data that describes a mesh file. Valid input files are .dmx, .fbx, .obj, and .smd."
		"Attribute.CVmesh.m_meshName"		"Mesh Name"
		"Attribute.CVmesh.m_meshName:help"		"The name of the mesh. "
		"Attribute.CVmesh.m_meshFile"		"Mesh File"
		"Attribute.CVmesh.m_meshFile:help"		"The content side file that is compiled. Valid file types are .dmx, .fbx, .smd, and .obj"
		"Attribute.CVmesh.m_materialSearchPath"		"Material Search Path"
		"Attribute.CVmesh.m_materialSearchPath:help"		"Optional mod relative path that adds an additional search path where the compiler looks for materials. For example entering \"materials/environments/rocks/\" will add that as a possible location for materials, in addition to looking in the location  contained in the input mesh file."
		"Attribute.CVmesh.m_bSkinParentedObjects"		"Skin Parented Objects"
		"Attribute.CVmesh.m_bSkinParentedObjects:help"		"Enabling this will force a hierarchy of objects to be treated as a joint based skeleton. For example a chain of parented cubes will show up as a series of joints with the cubes skinned to each joint. This is on by default."
		"Attribute.CVmesh.m_bExpensiveTangents"		"Use Expensive Tangents"
		"Attribute.CVmesh.m_bExpensiveTangents:help"		"Enabling this will use uncompressed tangents. This will result in better looking results in some cases, but will also increase the size of the compiled model."
		"Attribute.CVmesh.m_bIgnoreCloth"		"Ignore Cloth Attributes"
		"Attribute.CVmesh.m_bIgnoreCloth:shorthelp"		"Act as if there are no cloth_enable and other cloth_* maps painted on the mesh. When checked, no cloth will be created from this mesh. "
		"Attribute.CVmesh.m_bIgnoreCloth:help"		"<p>Act as if there are no cloth_enable and other cloth_* maps painted on the mesh. When checked, no cloth will be created from this mesh. </p>
<p>Useful for temporarily turning off cloth, or, when using joint-backsolved proxies, switching between using the joints authored with the mesh, and using joints generated from the cloth proxy.</p>
<p>When you use a cloth proxy, it normally generates a joint per proxy vertex, resulting in a lot of joints. Sometimes you want to control how the cloth mesh bends (for visual performance) and how many joints you have in the mesh (for animation/CPU performance). In those cases, you can check \"Back-solve joints\" in the proxy, which will not stop proxy from generating per-vertex joints, but will ensure that the joints that are already in the mesh are back-solved and move with the cloth. If you don't have any cloth_enable painted on the render mesh (or if you check Ignore Cloth Attributes), the render mesh will only be bound to the authored joints, and the generated proxy joints will not be used, and thus will be omitted from the model skeleton, potentially saving some perf.</p>

<p>
<img src='game:tools/images/model_editor/cloth_backsolve_demo.png' /></p>"
		"Attribute.CVClothProxyMesh.m_bMapUsingUVs"		"Map Using UVs"
		"Attribute.CVClothProxyMesh.m_bMapUsingUVs:shorthelp"		"Use UV coordinates to match cloth proxy mesh to the render mesh"
		"Attribute.CVClothProxyMesh.m_bMapUsingUVs:help"		"Use UV coordinates to match cloth proxy mesh to the render mesh. 
By default, cloth proxy doesn't have to have UVs, and render mesh is projected onto cloth proxy mesh directly using the authored (undeformed) relaxed mesh positions.
Not implemented as of Dec 2014"
		"Attribute.CVClothProxyMesh.m_flEnvelope"		"Envelope"
		"Attribute.CVClothProxyMesh.m_flEnvelope:shorthelp"		"The max distance to project render mesh onto cloth proxy mesh. Range: 0 - infinity (inches)"
		"Attribute.CVClothProxyMesh.m_flEnvelope:help"		"The max distance to project render mesh onto cloth proxy mesh. Range: 0 - infinity (inches)
When trying to map cloth proxy mesh onto render mesh (which may have totally different topology and strucutre), the render mesh vertices are projected onto polygons of cloth proxy mesh. This is the maximum projection distance between the render mesh vertices and corresponding points on the cloth proxy mesh polygons they are projected onto. 
By default , this is set to a large value to make it possible to project anything onto anything to always get some result, but sometimes it may not be desirable."
		"Attribute.CVClothProxyMesh.m_flCollapseTinyEdges"		"Collapse Tiny Edges"
		"Attribute.CVClothProxyMesh.m_flCollapseTinyEdges:shorthelp"		"Collapse edges below threshold. May be used to create ropes out of polygons."
		"Attribute.CVClothProxyMesh.m_flCollapseTinyEdges:help"		"Collapse edges below threshold. May be used to create ropes out of polygons.
Any edge shorter than the specified length will be collapsed. As a result, sliver quads or tris may be converted to rods (elements of ropes). Not implemented as of Dec 2014"
		"Attribute.CVClothProxyMesh.m_flBackSolveInfluenceThreshold"		"Back-solve min weight"
		"Attribute.CVClothProxyMesh.m_flBackSolveInfluenceThreshold:shorthelp"		"Range: 0-1. Minimal joint blend weight for that joint to be affected by back-solving"
		"Attribute.CVClothProxyMesh.m_flBackSolveInfluenceThreshold:help"		"<p>Range: 0-1. Minimal joint blend weight for that joint to be affected by back-solving.</p><p>
Back-solving a joint involves taking the vertices that are bound to it, and computing where the joint should be to match those vertices as close as possible. When a vertex-joint blend weight is below this threshold, this vertex will not be used for that computation.</p><p>
<img src='game:tools/images/model_editor/cloth_backsolve_demo.png' /></p>"
		"Attribute.CVClothProxyMesh.m_bBackSolveJoints"		"Back-solve joints"
		"Attribute.CVClothProxyMesh.m_bBackSolveJoints:shorthelp"		"Back-solve joints from deformed vertices"
		"Attribute.CVClothProxyMesh.m_bBackSolveJoints:help"		"<p><b>Back-solve joints from deformed vertices.</b></p>
<p>
Sometimes it's useful for the authored joints to be moved by cloth. It's not useful when you want to animate them, when you want the animation to affect the cloth. But when you want un-animated joints to be moved by cloth, this is your checkbox.
Cloth proxy vertices may be bound to some joints. Those joints may directly move those vertices if they are static (when cloth_enable attribute is black). But when those vertices are dynamic (cloth_enable attribute is white), they can affect (rotate and move) the joints. The joints are solved to try to match the simulated vertex positions as close as possible (without scale or skew). This flag may be used in conjunction with render mesh without cloth attributes or with cloth attributes ignored (see Ignore Cloth Attributes option on render mesh). If the render mesh doesn't follow cloth, it still follows the originally authored (and maybe animated) joints. With this checkbox, cloth will move and rotate those joints.
</p><p>
When you use a cloth proxy, it normally generates a joint per proxy vertex, resulting in a lot of joints. Sometimes you want to control how the cloth mesh bends (for visual performance) and how many joints you have in the mesh (for animation/CPU performance). In those cases, you can check \"Back-solve joints\" in the proxy, which will not stop proxy from generating per-vertex joints, but will ensure that the joints that are already in the mesh are back-solved and move with the cloth. If you don't have any cloth_enable painted on the render mesh (or if you check Ignore Cloth Attributes), the render mesh will only be bound to the authored joints, and the generated proxy joints will not be used, and thus will be omitted from the model skeleton, potentially saving some perf.
</p>
<img src='game:tools/images/model_editor/cloth_backsolve_demo.png' />"
		"Attribute.CVClothProxyMesh.m_bBackSolveNonClothJoints"		"Back-solve Joints affecting cloth-disabled verts"
		"Attribute.CVClothProxyMesh.m_bBackSolveNonClothJoints:shorthelp"		"Cloth affects joints with static cloth nodes bound"
		"Attribute.CVClothProxyMesh.m_bBackSolveNonClothJoints:help"		"<p>
Sometimes it's useful for the authored joints to be moved by cloth (see Back-solve Joints checkbox). It's not useful when you want to animate them, when you want the animation to affect the cloth. But animation will always affect the <b>static</b> verts/nodes of the cloth, those painted black (in <em>cloth_enable </em>attribute). Those node drive the rest of the cloth simulation, and it would look strange to try to back-solve joints to which those vertices are skinned, because those vertices would be deformed in unexpected ways.
</p>
<p>However, sometimes it's useful to do so, especially when there are just a few vertices that don't deform too much when the joint is rotating. This checkbox allows you to do that. </p>"
		"Attribute.CAuthPhysFx.m_flDefaultSurfaceStretch"		"Surface Stretch (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultSurfaceStretch:shorthelp"		"Range: -inf..+inf. Most useful range: 0..1. Stretchiness, droopiness of cloth surface (but not ropes/rods)"
		"Attribute.CAuthPhysFx.m_flDefaultSurfaceStretch:help"		"<p>A measure of stretchiness. 0 is the stiffest. 1 is extremely loose. +inf would effectively disable the solver completely. Small negative values are inherently unstable, but effectively make cloth over-stiff, overshooting the solver on every iteration. It may generate interesting jittery special effects in some cases, but will make cloth unstable in many other cases.</p> 
<p>Technically, this is the rate at which quads and tris are allowed to contract every time step. It is exponential, so 0 becomes the multiplier of exp( 0 ) = 1, allowing for full solve. 1 becomes exp( -1 ) ~= 0.37, so the solver only has the weight of .37, making the solver very droopy and relaxed. Values beyond 1 will quickly make multiplier almost-0, making solver effectively (almost) disabled</p>
<p><img src='game:tools/images/model_editor/cloth_stretch_demo2.png' /></p>"
		"Attribute.CAuthPhysFx.m_flDefaultThreadStretch"		"Rod Stretch (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultThreadStretch:shorthelp"		"Range: -inf..+inf. Most useful range: 0..1. Stretchiness, droopiness of cloth surface (but not ropes/rods)"
		"Attribute.CAuthPhysFx.m_flDefaultThreadStretch:help"		"<p>A measure of stretchiness. 0 is the stiffest. 1 is extremely loose. +inf would effectively disable the solver completely. Small negative values are inherently unstable, but effectively make cloth over-stiff, overshooting the solver on every iteration. It may generate interesting jittery special effects in some cases, but will make cloth unstable in many other cases.</p>
<p>Technically, this is the rate at which <b>rods</b> are allowed to contract every time step. It is exponential, so 0 becomes the multiplier of exp( 0 ) = 1, allowing for full solve. 1 becomes exp( -1 ) ~= 0.37, so the solver only has the weight of .37, making the solver very droopy and relaxed. Values beyond 1 will quickly make multiplier almost-0, making solver effectively (almost) disabled</p>
<p><img src='game:tools/images/model_editor/cloth_stretch_demo2.png' /></p>"
		"Attribute.CAuthPhysFx.m_flDefaultGravityScale"		"Gravity (-inf..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultGravityScale:shorthelp"		"Range:-inf..+inf; Gravity, 1 means 1 earth gravity -1 means earth gravity directed upwards"
		"Attribute.CAuthPhysFx.m_flDefaultGravityScale:help"		"Gravity scale multiplier. 1.0 means normal Earth gravity. -1.0 means gravity, directed upwards. 2 means 2 times the Earth gravity, etc."
		"Attribute.CAuthPhysFx.m_flQuadBendTolerance"		"Triangulate quads bent more than (0..1)"
		"Attribute.CAuthPhysFx.m_flQuadBendTolerance:shorthelp"		"Range: 0..1. Triangulate threshold for non-flat quads"
		"Attribute.CAuthPhysFx.m_flQuadBendTolerance:help"		"Triangulate quads that have curvature over specified threshold. 
0.0 means \"triangulate almost all quads\", because roundoff errors make sure there are almost never completely flat quads (except axis-aligned quads)
Values close to 1 may cause some weird behavior in some extreme cases.
1.0 means \"Do not triangulate any quads, even if they are self-intersecting\"
Values over 1 effectively mean the same."
		"Attribute.CAuthPhysFx.m_flAddCurvature"		"Minimal curvature (0..1)"
		"Attribute.CAuthPhysFx.m_flAddCurvature:shorthelp"		"Range: 0..1. Minimal allowed curvature"
		"Attribute.CAuthPhysFx.m_flAddCurvature:help"		"0 means edges may bend and fold as they please. 
0.5 means edges will try to maintain no less than right-angle bend (or the bend at relaxed position, whichever is smaller)
1.0 means any edge will try to maintain no more bend than in relaxed position. 

In order for this option to work, <b>m_bAddStiffnessRods</b> must be on. The stiffness rods are controlling the curvature, that's how it's implemented."
		"Attribute.CAuthPhysFx.m_flDefaultVelAirDrag"		"Viscous Air Drag (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultVelAirDrag:shorthelp"		"Air Drag coefficient multiplied by particle velocity^2, emulates viscous air drag effect"
		"Attribute.CAuthPhysFx.m_flDefaultVelAirDrag:help"		"Air Drag coefficient multiplied by particle velocity^2, emulates viscous friction effect.
<ul>
<li><b>0.0</b> means no viscous drag. This is unrealistic.</li>
<li><b>1.0</b> simulates light objects in air in normal gravity, or heavy objects in normal graivty but in liquid</li>
<li><b>10.0</b> is like moving through molasses, may be used for artistic effect.</li>
<li><b>+inf</b> is kind of strange, as it doesn't exactly mean stopping all motion,but it means all velocities must be infinitisemally small, which practically means motion is almost extinguished. In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>
</ul>"
		"Attribute.CAuthPhysFx.m_flDefaultExpAirDrag"		"Simple Drag (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultExpAirDrag:shorthelp"		"Simple linear drag, multiplied by particle velocity"
		"Attribute.CAuthPhysFx.m_flDefaultExpAirDrag:help"		"<P>Simple drag. Comparing to viscous drag: simple drag affects slow-moving particles
 more and fast-moving particles less than viscous drag. Every particle velocity is shed at the rate of Simple Drag. </P>
<P>Technically, the velocity loss is exponential and proportional to this value.</P>
<ul>
<li><b>0.0</b> means there is no drag</li>
<li><b>1.0</b> is quite a lot of drag. Quantitatively, it means particle is trying to shed velocity in a second, and would stop in a second if it didn't reduce velocity, thus reducing the drag.</li>
<li><b>10.0</b> is like moving through molasses, unrealistic drag that may be used for artistic effect</li>
<li><b>+inf</b> would mean drag stops particles in infinitisimal amount of time, making movement impossible.In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>
</ul>"
		"Attribute.CAuthPhysFx.m_flDefaultVelQuadAirDrag"		"Viscous Air Drag across surface area (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultVelQuadAirDrag:shorthelp"		"Air Drag coefficient multiplied by quad velocity^2, emulates viscous air drag effect"
		"Attribute.CAuthPhysFx.m_flDefaultVelQuadAirDrag:help"		"<p><b>Only affects Quads or Tris!</b></p>
<p>
Air Drag coefficient multiplied by velocity^2, emulates viscous friction effect. Forces are applied along surface normals, not along particle path directions.</p>
<p><ul>
<li><b>0.0</b> means no viscous drag. This is unrealistic.</li>
<li><b>1.0</b> simulates light objects in air in normal gravity, or heavy objects in normal graivty but in liquid</li>
<li><b>10.0</b> is like moving through molasses, may be used for artistic effect.</li>
<li><b>+inf</b> is kind of strange, as it doesn't exactly mean stopping all motion,but it means all velocities must be infinitisemally small, which practically means motion is almost extinguished. In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>
</ul>
</p>"
		"Attribute.CAuthPhysFx.m_flDefaultExpQuadAirDrag"		"Simple drag across surface area (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultExpQuadAirDrag:shorthelp"		"Simple linear drag across surface area, multiplied by velocity"
		"Attribute.CAuthPhysFx.m_flDefaultExpQuadAirDrag:help"		"<p><b>Only affects Quads or Tris!</b></p>
<P>Simple drag.  Forces are applied along surface normals, not along particle path directions. Comparing to viscous drag: simple drag affects slow-moving particles
 more and fast-moving particles less than viscous drag. Every particle velocity is shed at the rate of Simple Drag. </P>
<P>Technically, the velocity loss is exponential and proportional to this value.</P>
<ul>
<li><b>0.0</b> means there is no drag</li>
<li><b>1.0</b> is quite a lot of drag. Quantitatively, it means particle is trying to shed velocity in a second, and would stop in a second if it didn't reduce velocity, thus reducing the drag.</li>
<li><b>10.0</b> is like moving through molasses, unrealistic drag that may be used for artistic effect</li>
<li><b>+inf</b> would mean drag stops particles in infinitisimal amount of time, making movement impossible.In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>
</ul>"
		"Attribute.CAuthPhysFx.m_flDefaultVelRodAirDrag"		"Viscous Air Drag across rope lengths (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultVelRodAirDrag:shorthelp"		"Air Drag coefficient multiplied by rod velocity^2, emulates viscous air drag effect"
		"Attribute.CAuthPhysFx.m_flDefaultVelRodAirDrag:help"		"<p><b>Only affects Rods!</b></p>
<p>
Air Drag coefficient multiplied by velocity^2, emulates viscous friction effect. Forces are applied across rod lengths, not along particle path directions.</p>
<p><ul>
<li><b>0.0</b> means no viscous drag. This is unrealistic.</li>
<li><b>1.0</b> simulates light objects in air in normal gravity, or heavy objects in normal graivty but in liquid</li>
<li><b>10.0</b> is like moving through molasses, may be used for artistic effect.</li>
<li><b>+inf</b> is kind of strange, as it doesn't exactly mean stopping all motion,but it means all velocities must be infinitisemally small, which practically means motion is almost extinguished. In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>
</ul>
</p>"
		"Attribute.CAuthPhysFx.m_flDefaultExpRodAirDrag"		"Simple drag across rod length (0..+inf)"
		"Attribute.CAuthPhysFx.m_flDefaultExpRodAirDrag:shorthelp"		"Simple linear drag across rod lengths, multiplied by velocity"
		"Attribute.CAuthPhysFx.m_flDefaultExpRodAirDrag:help"		"<p><b>Only affects Rods!</b></p>
<P>Simple drag.  Forces are applied across rod length, not along particle path directions. Comparing to viscous drag: simple drag affects slow-moving particles
 more and fast-moving particles less than viscous drag. Every particle velocity is shed at the rate of Simple Drag. </P>
<P>Technically, the velocity loss is exponential and proportional to this value.</P>
<ul>
<li><b>0.0</b> means there is no drag</li>
<li><b>1.0</b> is quite a lot of drag. Quantitatively, it means particle is trying to shed velocity in a second, and would stop in a second if it didn't reduce velocity, thus reducing the drag.</li>
<li><b>10.0</b> is like moving through molasses, unrealistic drag that may be used for artistic effect</li>
<li><b>+inf</b> would mean drag stops particles in infinitisimal amount of time, making movement impossible.In practice, other forces will move particles, but any residual velocity will be zeroes making motion almost non-inertial.</li>
</ul>"
		"Attribute.CAuthPhysFx.m_flQuadVelocitySmoothRate"		"Heavy Leather Surface (0..1)"
		"Attribute.CAuthPhysFx.m_flQuadVelocitySmoothRate:shorthelp"		"Smoothing velocity field helps achieve \"Heavy leather\" look"
		"Attribute.CAuthPhysFx.m_flQuadVelocitySmoothRate:help"		"<p>Smooth the velocity field along the surface, to avoid ripples and waves characteristic of light silky cloth, and achieve more heavy, monolithic, shell-like look.</p>"
		"Attribute.CAuthPhysFx.m_flRodVelocitySmoothRate"		"Heavy Whip Rope (0..1)"
		"Attribute.CAuthPhysFx.m_flRodVelocitySmoothRate:shorthelp"		"Smoothing velocity field helps achieve \"Heavy whip\" look"
		"Attribute.CAuthPhysFx.m_flRodVelocitySmoothRate:help"		"<p>Smooth the velocity field along the rope length, to avoid ripples and waves characteristic of soft easily bendable materials, and achieve more heavy, monolithic, rod-like look.</p>"
		"Attribute.CAuthPhysFx.m_nQuadVelocitySmoothIterations"		"Ultra Heavy Surface (0..+inf)"
		"Attribute.CAuthPhysFx.m_nQuadVelocitySmoothIterations:shorthelp"		"Number of iterations the surface velocity field smoothing is applied"
		"Attribute.CAuthPhysFx.m_nQuadVelocitySmoothIterations:help"		"<p><b>Warning: expensive parameter, use with caution!</b></p>
<p>This is the number of iterations of velocity field smoothing to apply to a surface. Works in conjunction with QuadVelocitySmoothRate</p>"
		"Attribute.CAuthPhysFx.m_nRodVelocitySmoothIterations"		"Heavy Rope Iterations (0..+inf)"
		"Attribute.CAuthPhysFx.m_nRodVelocitySmoothIterations:shorthelp"		"Number of iterations the surface velocity field smoothing is applied"
		"Attribute.CAuthPhysFx.m_nRodVelocitySmoothIterations:help"		"<p><b>Warning: expensive parameter, use with caution!</b></p>
<p>This is the number of iterations of velocity field smoothing to apply to a surface. Works in conjunction with QuadVelocitySmoothRate</p>"
		"Attribute.CAuthPhysFx.m_flDefaultGroundFriction"		"S1 Ground Friction (0..1)"
		"Attribute.CAuthPhysFx.m_flDefaultGroundFriction:shorthelp"		"Source 1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_flDefaultGroundFriction:help"		"\"Ground Friction\" as defined in S1 cloth. It's kind of stickiness to the ground when ground collision is enabled. Do not use in new Source2-authored cloth."
		"Attribute.CAuthPhysFx.m_flAddWorldCollisionRadius"		"Cloth Thickness when colliding with meshes (0..+inf, inches)"
		"Attribute.CAuthPhysFx.m_flAddWorldCollisionRadius:shorthelp"		"Additional radius to add to particles colliding with mesh, because mesh consists of very thin quads"
		"Attribute.CAuthPhysFx.m_flAddWorldCollisionRadius:help"		"When cloth collides with world mesh, only cloth nodes/verts are colliding. Since mesh thickness is essentially zero, particles can easily end up on the wrong side of the mesh. Hence, we need a tuning parameter that stops particles from penetrating the mesh. This is it."
		"Attribute.CAuthPhysFx.m_flDefaultWorldCollisionPenetration"		"S1 World Collision Penetration (0..1)"
		"Attribute.CAuthPhysFx.m_flDefaultWorldCollisionPenetration:shorthelp"		"Source1 compatibility parameter for how much particles penetrate the ground"
		"Attribute.CAuthPhysFx.m_flDefaultWorldCollisionPenetration:help"		"Do not use in Source2 authored cloth"
		"Attribute.CAuthPhysFx.m_flLocalForce"		"S1 Local Force (0..1)"
		"Attribute.CAuthPhysFx.m_flLocalForce:shorthelp"		"Source 1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_flLocalForce:help"		"<p>Source 1 compatibility parameter Local Force is used to distinguish whether cloth reacts to entity moving in the world or not (ie. whether it's effectively simulated in local entity frame or in the world). </p>
<p>The meaning of values is kept as in Source 1. The meaning is opposite to LocalRotation, which is frustrating, but compatible with Source 1 .cloth files.</p>
<p><ul><li><b>0.0</b> Means sim in local frame. Cloth will not react to dragging entity through the world</li>
<li><b>1.0</b> Means sim in global world frame. Cloth will drag behind entity when moving entity around the world. This is the default.</li>
</ul>
</p>"
		"Attribute.CAuthPhysFx.m_flLocalRotation"		"S1 Local Rotation (0..1)"
		"Attribute.CAuthPhysFx.m_flLocalRotation:shorthelp"		"Source 1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_flLocalRotation:help"		"<p>Source 1 compatibility parameter Local Rotation is used to distinguish whether cloth reacts to entity moving in the world or not (ie. whether it's effectively simulated in local entity frame or in the world). </p>
<p>The meaning of values is kept as in Source 1. The meaning is opposite to LocalForce, which is frustrating, but compatible with Source 1 .cloth files.</p>
<p><ul>
<li><b>0.0</b> Means sim in global world frame. Cloth will drag around rotation axis when rotating entity in the world. </li>
<li><b>1.0</b> Means sim in local frame. Cloth will not react to rotating entity.</li>
</ul>
</p>"
		"Attribute.CAuthPhysFx.m_flVolumetricSolveAmount"		"Back-solve Joint Feedback (0..1)"
		"Attribute.CAuthPhysFx.m_flVolumetricSolveAmount:shorthelp"		"How much the joint back-solve (if any) feeds forward into the simulation"
		"Attribute.CAuthPhysFx.m_flVolumetricSolveAmount:help"		"<p>Joint back-solving is a way for cloth to control the render mesh via its own authored bones, as opposed to controlling render mesh through bones generated from cloth proxy mesh.</p>
<p>When cloth proxy computes those bones, by default it doesn't affect the simulation, it only affects the render mesh</p>
<p>If you set this to 1.0, the simulation will be affected. The vertices will be rearranged every frame to follow the back-solved joints, effectively creating a volumetric solve effect. It can be useful for plants and other volumetric effect props where it's important to maintain initial 3D structure of the object. </p>"
		"Attribute.CAuthPhysFx.m_bFollowTheLead"		"S1 Compatibility"
		"Attribute.CAuthPhysFx.m_bFollowTheLead:shorthelp"		"Source1 compatible non-physical behavior"
		"Attribute.CAuthPhysFx.m_bFollowTheLead:help"		"This ensures the Follow-The-Lead constraint solving strategy for rods. It is non-physical and should never be used for anything, ever. Except to emulate precisely what the Source1 solver does. Also, good for experimenting with bizzare artistic effects."
		"Attribute.CAuthPhysFx.m_bUsePerNodeLocalForceAndRotation"		"Per-node local force and rotation"
		"Attribute.CAuthPhysFx.m_bUsePerNodeLocalForceAndRotation:shorthelp"		"Source 1 compatiblity parameter"
		"Attribute.CAuthPhysFx.m_bUsePerNodeLocalForceAndRotation:help"		"<p>Allow to use per-node LocalForce and LocalRotation parameters</p>
<p>This currently is only useful to emulate Source1 cloth system with multiple cloth pieces, but in the future if these parameters prove useful, we might paint them as attribute maps on cloth proxies or meshes<p>"
		"Attribute.CAuthPhysFx.m_bUnitlessDamping"		"Unitless Damping"
		"Attribute.CAuthPhysFx.m_bUnitlessDamping:shorthelp"		"Source1 had damping coupled to particle mass. "
		"Attribute.CAuthPhysFx.m_bUnitlessDamping:help"		"Changes the meaning of damping parameter. If this is <b>on</b> (the default), then damping is unitless value with the most useful range of 0..1, and it damps regardless of mass. If it's <b>off</b>, then damping is affected by particle mass. Mostly useful for backwards compatibility with source1 cloth assets. Do not use for in new Source2 authored assets unless you are sure you want to couple particle masses and damping."
		"Attribute.CAuthPhysFx.m_bExplicitMasses"		"Explicit masses"
		"Attribute.CAuthPhysFx.m_bExplicitMasses:shorthelp"		"Specify particle masses explicitly, and don't allow cloth builder to automatically determine them"
		"Attribute.CAuthPhysFx.m_bExplicitMasses:help"		"<p>Specify particle masses explicitly, and don't allow cloth builder to automatically determine them</p>
<p>When cloth is built, particle masses are normally auto-assigned based on the area of triangles and lengths of rods, so that areas with high vertex density don't become overweight</p>
<p>However sometimes you want cloth to simulate a carefully placed network of nodes where you know exactly how much each node should weigh. In this case, check this checkbox. By default, all masses with be equal to 1.0, unless you paint the cloth_mass map. If you turn this off, cloth_mass will be blended with the vertex surrounding quad areas</p>"
		"Attribute.CAuthPhysFx.m_bUninertialRods"		"S1 Uninertial Rods"
		"Attribute.CAuthPhysFx.m_bUninertialRods:shorthelp"		"Horrible, terrible Source1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_bUninertialRods:help"		"Never, ever turn this on unless trying to emulate Source1 cloth exactly. This kills integrator stability and generally makes all kinds of badness to happen."
		"Attribute.CAuthPhysFx.m_bForceWorldCollisionOnAllNodes"		"(Test) Force S1 World Collision on all nodes"
		"Attribute.CAuthPhysFx.m_bForceWorldCollisionOnAllNodes:shorthelp"		"Forces all nodes to collide with the ground, in Source1 sense"
		"Attribute.CAuthPhysFx.m_bForceWorldCollisionOnAllNodes:help"		"In Source1, \"world collision\" was a per-cloth-piece flag that made a particle collide with the ground plane. This is a test parameter that allows you to force this turned on for all nodes, to make the whole cloth collide with the ground. Useful for quick testing, but may be used for simple ground colliding cloth when performance isn't much of an issue."
		"Attribute.CAuthPhysFx.m_nMergePriority"		"Parameter Merge priority"
		"Attribute.CAuthPhysFx.m_nMergePriority:shorthelp"		"Priority of these parameters when merging cloth from multiple sources"
		"Attribute.CAuthPhysFx.m_nMergePriority:help"		"<p>Priority of these parameters when merging cloth from multiple sources.</p>
<p>When authoring cloth by painting cloth_enable map in Maya, and then changing parameters in Source2 Model Editor, there are two sources of data: that exported from Maya, and that authored in Source2 Model Editor. They are merged together, so that you can author some cloth collision in one, and some in the other, and they will be appended. But some parameters cannot be appended and the cloth compiler has to choose between the two. In these cases, it'll choose the source with higher Merge Priority.</p>
<p> By default, cloth authored in Maya or Modo have priority 1. If, after authoring cloth in Maya or Modo you want to add .collision file to tweak some parameters, it will be assigned priority 2, and will thus override what you authored in Maya (it will not override cloth polygons and such, as they can be merged; but it will override e.g. the default gravity scale multiplier that affects the whole character). However, if you first author some cloth in Model Editor, it'll have priority 0. If you then export something from Maya (like cloth proxy), it'll have default parameters and priority 1, thus overwriting the parameters you previously authored in Model Editor. To revert back to Model Editor-edited parameters, simply set the priority to 2.</p>"
		"Attribute.CAuthPhysFx.m_bNewStyle"		"New Style cloth"
		"Attribute.CAuthPhysFx.m_bNewStyle:shorthelp"		"S1 compatibility parameter"
		"Attribute.CAuthPhysFx.m_bNewStyle:help"		"Used for debugging leave this on, please."
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldMeshes"		"Collide With Meshes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldMeshes:shorthelp"		"Turn on collision with physical mesh shapes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldMeshes:help"		"Turn on collision with physical mesh shapes."
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldCapsulesAndSpheres"		"Collide With Capsules and Spheres"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldCapsulesAndSpheres:shorthelp"		"Turn on collision with physical capsule and sphere shapes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldCapsulesAndSpheres:help"		"Turn on collision with physical capsule and sphere shapes. Turn this on to interact with player's capsule, for example."
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldHulls"		"Collide With Convex Hulls"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldHulls:shorthelp"		"Turn on collision with physical convex hull shapes"
		"Attribute.CAuthPhysFx.m_bCanCollideWithWorldHulls:help"		"Turn on collision with physical convex hull shapes"
		"Attribute.CAuthPhysFx.m_bAddStiffnessRods"		"Add Stiffness Rods"
		"Attribute.CAuthPhysFx.m_bAddStiffnessRods:shorthelp"		"Add rods crossing edges that add stiffness to the structure."
		"Attribute.CAuthPhysFx.m_bAddStiffnessRods:help"		"<p>This is just a quality parameter to make cloth more stiff and responsive at the same time. If you want droopy looking, relaxed and stretchy cloth, turn this off, as turning it off will both make cloth more droopy and simulation cheaper.
</p>
<p>
Another function is to provide bend springs that also act as stretch springs. They will only resist bending if the curvature is not zero, i.e. either you have to paint cloth_bend_stiffness map or set Add Curvature parameter to something more than 0 (1 recommended for less-bendable cloth)
</p>
<p>
This may create issues sometimes, especially when your (goal) attractor maps are not smooth over 3 consecutive vertices.
</p>
<p>
If you only want the bend springs without the issues and stiffness that comes with Bend-and-Stretch springs, uncheck this option and check Add Bend-only Springs
</p>"
		"Attribute.CAuthPhysFx.m_bRigidEdgeHinges"		"Shell-like No Bend"
		"Attribute.CAuthPhysFx.m_bRigidEdgeHinges:shorthelp"		"Try to maintain shell-like structure of cloth, avoid bending at the edges"
		"Attribute.CAuthPhysFx.m_bRigidEdgeHinges:help"		"Use this in conjunction with <em>AddStiffnessRods</em> <b>ON</b> and <em>AddCurvature </em><b>1.0</b> in order to achieve volumetric-like solve effects. Also, you can use this to try to keep cloth in the original shape , so that it's shell-like"
		"Attribute.CVClothProxyMesh.m_bFlexClothBorders"		"Allow border joint rotation"
		"Attribute.CVClothProxyMesh.m_bFlexClothBorders:shorthelp"		"Allow Rotation of Joints at the boder between cloth and rigid surface"
		"Attribute.CVClothProxyMesh.m_bFlexClothBorders:help"		"<p>Allow Rotation of Joints at the boder between cloth and rigid surface.</p>
<p>Cloth render mesh is controlled by joints that move and rotate (and sometimes may stretch and skew, with special setups). Those joints that are just on the border, i.e. joints controlled by animation, often influence both cloth and non-cloth vertices.</p><p> Sometimes it's useful to lock those border joints to their animated rotations (positions are normally locked anyway). But sometimes it's useful to let them rotate freely while keeping position locked.</p>
<p>This option allows you to choose between the two modes</p>
<p><img src='game:tools/images/model_editor/flex_cloth_border_joints.png' /></p>"
		"Element.CVClothProxyMeshList"		"Cloth Proxy Mesh List"
		"Element.CVClothProxyMeshList:help"		"<p>For any prop or character you want to have cloth on, you can either paint cloth_enable attribute on the render mesh, or (if the render mesh topology does not simulate well) model a <b>proxy </b>mesh that will simulate and deform the render mesh as it simulates. </p><p>The deformation resembles that of the maya Wrap deformer, but it happens at runtime, which means there are additional limitations. There may only be up to 4 nodes (the simulating cloth mesh vertices) infuencing a single vertex in the render mesh, which is much more limiting than Maya's wrap deformer that may easily use 16 to achieve a smooth look.</p><p> In the cases when you can't achieve smooth enough look with it, you can bind both render mesh and proxy mesh to the same skeleton, and enable Back-Solve Joints option in the proxy. Then don't paing cloth_enable attribute on the original render mesh (or check the \"Ignore Cloth Attributes\" option on the render mesh to ignore attributes you already painted). You'll have the full control over how you skin the render mesh, and the cloth will solve and control those joints, so the skin will deform smoothly no matter what.</p>
<p>
<img src='game:tools/images/model_editor/cloth_backsolve_demo.png' /></p>"
		"Attribute.CVClothProxyMesh.m_meshName:help"		"The name of the cloth proxy mesh is for documentation purposes only and doesn't affect the compilation process"
		"Element.CVClothProxyMesh"		"Cloth Proxy Mesh"
		"Element.CVClothProxyMesh:shorthelp"		"The mesh that will actually simulate, and the simulation will be transferred to render mesh"
		"Element.CVClothProxyMesh:help"		"<p>For any prop or character you want to have cloth on, you can either paint cloth_enable attribute on the render mesh, or (if the render mesh topology does not simulate well) model a <b>proxy </b>mesh that will simulate and deform the render mesh as it simulates. </p><p>The deformation resembles that of the maya Wrap deformer, but it happens at runtime, which means there are additional limitations. There may only be up to 4 nodes (the simulating cloth mesh vertices) infuencing a single vertex in the render mesh, which is much more limiting than Maya's wrap deformer that may easily use 16 to achieve a smooth look.</p><p> In the cases when you can't achieve smooth enough look with it, you can bind both render mesh and proxy mesh to the same skeleton, and enable Back-Solve Joints option in the proxy. Then don't paing cloth_enable attribute on the original render mesh (or check the \"Ignore Cloth Attributes\" option on the render mesh to ignore attributes you already painted). You'll have the full control over how you skin the render mesh, and the cloth will solve and control those joints, so the skin will deform smoothly no matter what.</p>
<p>
<img src='game:tools/images/model_editor/cloth_backsolve_demo.png' /></p>"
		"Attribute.CVClothProxyMeshList.m_bDriveMeshesWithBacksolvedJointsOnly"		"Back-solved Joints drive meshes"
		"Attribute.CVClothProxyMeshList.m_bDriveMeshesWithBacksolvedJointsOnly:shorthelp"		"If your cloth proxy has \"Back-solve joints\" checked, this will ensure that no additional bones are created in render meshes."
		"Attribute.CVClothProxyMeshList.m_bDriveMeshesWithBacksolvedJointsOnly:help"		"<p>This will ensure that no additional bones are created in render meshes, and the existing bones with dynamic proxy verts are back-solved (but also see: ).It's equivalent to setting render meshes' checkbox \"Ignore Cloth Attributes\" and If your cloth proxy checkbox \"Back-solve Joints\".</p>
<p>In order to create this setup successfully, don't forget about the following: <ul><li>You need to skin the proxy as well as render mesh for back-solving to work, because proxy needs to know which vertices connect to which bones. In Modo/Maya, bones drive proxy vertices. The cloth solver puts it upside down and drives bones with vertices. </li><li>You don't actually need the cloth_enable map on the driven mesh, because it's not participating in anything cloth related. Cloth drives bones, and bones then drive the render mesh, but render mesh doesn't need to know about cloth. If you already painted that map and you don't want to delete it (it's work that may be useful at some point), it'll get ignored as if  the \"Ignore Cloth Attributes\" checkbox is checked on all the render meshes. Itll behave as if you never painted the cloth_enable map on it.</li></ul></p>

<p>
<img src='game:tools/images/model_editor/cloth_backsolve_demo.png' /></p>"
		"Attribute.CVClothProxyMeshList.m_flMatchProxiesToMeshes"		"Auto-Match proxies to meshes (0..1)"
		"Attribute.CVClothProxyMeshList.m_flMatchProxiesToMeshes:shorthelp"		"Will attempt to match contiguous cloth proxy pieces to render mesh pieces"
		"Attribute.CVClothProxyMeshList.m_flMatchProxiesToMeshes:help"		"<p>When there are multiple cloth pieces that come close to each other or even intersect, this is how you automatically disambiguate which piece of cloth proxy affects which piece of render mesh. Without this option, intersecting cloth pieces will move as if stuck together and will stretch in bad ways.</p>

<ul>
<li><b>0.0</b> means don't try to match, project the whole render mesh onto the cloth proxy mesh</li>
<li><b>1.0</b> means definitely try to match cloth pieces to render mesh pieces, even if the match is not very good</li>
</ul>"
		"Attribute.CVClothProxyMeshList.m_bRemoveUnusedBonesEnabled"		"Remove unused bones"
		"Attribute.CVClothProxyMeshList.m_bRemoveUnusedBonesEnabled:shorthelp"		"Tries to search and remove bones that do not affect render mesh. Does not affect cloth simulation."
		"Attribute.CVClothProxyMeshList.m_bRemoveUnusedBonesEnabled:help"		"Tries to search and remove bones that do not affect render mesh. Does not affect cloth simulation."
		"Attribute.CVmesh.m_bLegacySkinParentedTransforms"		"Skin Parented Transforms"
		"Attribute.CVmesh.m_bLegacySkinParentedTransforms:shorthelp"		"Create implicit joints for normal transform and skin meshes to them"
		"Attribute.CVmesh.m_bLegacySkinParentedTransforms:help"		"By default only joints are converted into a game mesh and meshes can only be skinned to joints.  This option will create an implicit joint for every transform in the scene and will also implicitly skin meshes to their closest parent.  This option implies <a href='helpsystem:Attribute.CVmesh.m_bSkinParentedObjects'>Skin Parented Objects</a>"
		"Attribute.CAuthPhysBody.m_bUseInCloth"		"Use in Cloth Collision"
		"Attribute.CAuthPhysBody.m_bUseInCloth:shorthelp"		"Use this shape as collision in cloth"
		"Attribute.CAuthPhysBody.m_bUseInCloth:help"		"When checked, this collision shape will be used in cloth to collide against cloth of the same character. There is a number of restrictions, because cloth doesn't use the same collision system as physics for performance reasons.
Cloth supports collision with spheres and capsules. This checkbox will have effect on those. Cloth does not support performant collision with hulls (although there is experimental support, but it's too slow to be practical). Cloth also supports collision with planes and tapered capsules, and also \"inside\" collision, where a piece of cloth can be held within the bounds of a sphere or a tapered capsule. 
There's no way to author such collision conveniently in model_editor yet. The plan is to build the tools as we need them.
Note that different characters will not collide with each other's cloth."
		"Attribute.CAuthPhysFx.m_bAddBendOnlyRods"		"Add Bend-only Springs"
		"Attribute.CAuthPhysFx.m_bAddBendOnlyRods:help"		"<p>This option adds traditional bend springs, if curvature is not 0.</p>

<p>That is, you must either paint cloth_bend_stiffness map or set Add Curvature option to non-0 (try 1) for this option to have effect. Also, turn off Bend-and-Stretch springs, because they supercede this option.</p>"
		"clothchain.joint_name"		"Joint Name"
		"clothchain.joint_name:shorthelp"		"Joint Name"
		"clothchain.joint_name:help"		"<style>
table {
  border: 2px solid black;
  margin: 2px
  padding: 3px;
}
p, td {padding:3px;}
</style>
<table border=\"1\"><tr><td><p>Name of the joint tied to cloth node(s)</p>
<p>In the simplest case, the joint will be simulated as a single point (cloth node, or vertex) and joint orientation will be figured out using heuristics to reduce twisting along joint chain. You should orient +X or -X along the chain.</p></td><td>
In more complex cases, the joint will drive and be driven by multiple generated nodes. E.g. here every joint is driven by 2 vertices to the sides
</td></tr><tr><td>
<img src='game:tools/images/model_editor/clothchain_simple.gif' />
</td><td>
<img src='game:tools/images/model_editor/clothchain_extrude2.jpg' />
</td></tr></table>"
		"clothchain.joint_parent"		"Parent Joint"
		"clothchain.joint_parent:shorthelp"		"Name of the parent joint"
		"clothchain.joint_parent:help"		"<p>Cloth chain relies on joint hierarchy information to generate cloth around the joints</p>
<p>All the different types of springs are generated by going to parent, grandparent or great-grandparent of the joint<p>"
		"clothchain.stretch_spring"		"Stretch Spring"
		"clothchain.stretch_spring:shorthelp"		"Structural Springs"
		"clothchain.stretch_spring:help"		"<p>Cloth chain relies on joint hierarchy information to generate cloth around the joints</p>
<p>All the different types of springs are generated by going to parent, grandparent or great-grandparent of the joint<p>
<table><th><tr font=\"large\"><td>Stretch</td><td>Bend</td><td>Torsion</td></tr></th>
<tr>
	<td style=\"background-color:yellow;color:black;\"><b>Stretch</b> springs are red. Connect structurally closest elements.</td>
	<td><b>Bend</b> springs are yellow. They skip a parent.</td>
	<td><b>Torsion</b> springs are blue. They skip <b>2</b> parents.</td>
</tr>
<tr>
	<td><img src='game:tools/images/model_editor/clothchain_stretch.jpg' /></td>
	<td><img src='game:tools/images/model_editor/clothchain_bend.jpg' /></td>
	<td><img src='game:tools/images/model_editor/clothchain_torsion.jpg' /></td>
<tr>"
		"clothchain.simulate"		"Simulate"
		"clothchain.simulate:shorthelp"		"Determines whether the joint simulates or is fixed"
		"clothchain.simulate:help"		"<style>
table {
  border: 2px solid black;
  margin: 2px
  padding: 3px;
}
p, td {padding:3px;}
</style>
<p>When Simulate is checked, the node(s) around this joint will be simulated, i.e. free to move.</p>
<p>When it's unchecked, those nodes will be fixed by animation</p>
<p>In the example below, the tip of the chain is simulated on the left, and fixed (by unchecking the Simulate box) on the right</p>
</p>The root of the chain is always fixed</p>
<table border=\"1\">
<tr>
	<td>Default setup for the joint chain: only one (root) joint is fixed. The rest are simulated.</td>
	<td>Chain fixed on both ends. Yellow and pink show the joints and their corresponding Simulate checkboxes</td>
</tr>
<tr>
	<td><img src='game:tools/images/model_editor/clothchain_simulated.jpg' /></td>
	<td><img src='game:tools/images/model_editor/clothchain_static_node.jpg' /></td>
</tr>
</table>"
		"clothchain.goal_strength"		"Goal Strength"
		"clothchain.goal_strength:shorthelp"		"How strong is the pull of the animated goals on cloth. Range: 0..1"
		"clothchain.goal_strength:help"		"<p>Cloth generally is driven by animation. Animation represents the \"goal\" for cloth. Every cloth node has corresponding animated position, and goal strength is the strength of the magnet that pulls cloth to its animated goal shape.</p>
<p>When you set the goal strength to 0, the pull is non-existent and animaiton doesn't matter to cloth. Cloth just hangs down</p>
<p> When you set the goal strength to 1, it will snap cloth to the animated goal with all its strength</p>"
		"clothchain.stray_radius"		"Stray Radius"
		"clothchain.stray_radius:shorthelp"		"How far cloth vertex may stray from animated goal position. Range: 0..inf"
		"clothchain.stray_radius:help"		"<p>Every cloth vertex has the animated position, defined by animation</p>
<p>If stray radius is set, it defines how far it can stray from that position. If you want cloth to move freely, but within some bounds away from the animation, set this to the distance</p>
<p>Unlike goal strength, stray radius has no effect when the vertex is within the range of its animated goal. If it strays beyond the range, it's yanked back hard (or rather with hardness determined by stray radius stretchiness)</p>
<p>Here's an example of restraining the range of sudden movement with stray radius. Note that the cloth stays well within the stray radius. In this case, it happens because stray radius restricted previous movement so the cloth doesn't have a long way to swing back from it. Cloth particles are not affected by stray radius at all when they're inside the stray radius sphere. They're only affected when they hit against the sphere boundary.</p>
<p><img src='game:tools/images/modeldoc_editor/cloth_stray_radius.png' /></p>"
		"clothchain.goal_damping"		"Goal Damping"
		"clothchain.goal_damping:shorthelp"		"How fast the goal strength pulls "
		"clothchain.goal_damping:help"		"<p>Cloth generally is driven by animation. Animation represents the \"goal\" for cloth. Every cloth node has corresponding animated position, and goal strength is the strength of the magnet that pulls cloth to its animated goal shape. Goal damping is how fast that magnet works.</p>
<p>When you set the goal damping to 0, the pull is fast and decisive.</p>
<p> When you set the goal strength to 1, the pull will be softer and slower</p>
<p>When the goal strength is weak or 0, goal damping doesn't matter</p>"
		"clothchain.collision_radius"		"Collision Radius"
		"clothchain.collision_radius:shorthelp"		"How thick the cloth vertex is"
		"clothchain.collision_radius:help"		"<p>Cloth vertices may collide with collision primitives: capsules, spheres, boxes. Collision Radius determines the distance at which the vertex collides with collision primitive and can be used to simulate cloth thickness or keep some vertices more distant from the collider.</p><p><img src='game:tools/images/model_editor/clothchain_collisionradius.jpg' /></p>"
		"clothchain.vertex_map"		"Vertex Map"
		"clothchain.vertex_map:help"		"Cloth vertices may belong to one or more vertex maps. This field is a name (or comma-separated names) of vertex map(s) this vertex belongs to. It's useful in applying effects such as wind to only subset of vertices in the system."
		"clothchain.world_collision"		"World Collision"
		"clothchain.world_collision:help"		"Check this for cloth vertices that need to collide with the ground. Currently, different games set up different ground colliders. Citadel has no ground collision, Dota has heightmaps, HL:A just uses a probe to find the floor plane."
		"clothchain.allow_rotation"		"Allow Rotation"
		"clothchain.allow_rotation:shorthelp"		"Whether to allow rotation of fixed joints"
		"clothchain.allow_rotation:help"		"<p>Has no effect on simulated joints.</p>

<p>When a joint is fixed (Simulated checkbox is unchecked), by default it will be fixed both in translation and rotation</p>
<p>You can allow a static joint to rotate by checking Allow Rotation. It will attempt to find neighbor cloth vertices and orient itself according to their movement. If there are no neighbors, rotation will be undefined</p><p>
<img src='game:tools/images/model_editor/flex_cloth_border_joints.png' /></p>"
		"clothchain.lock_translation"		"Lock Translation"
		"clothchain.lock_translation:shorthelp"		"Lock translation to bind pose relative to parent"
		"clothchain.lock_translation:help"		"<p>Prevent the joints from translating in parent space, allowing only rotation. Useful to prevent shear in mushy setups</p>
<p>This is a fixup used for advanced cloth setups. Here is an example: branching chain collapses</p><p><img src='game:tools/images/modeldoc_editor/unlock_translation_sample_bebop.png' /></p>
<p>But if you lock translation on child joints, they can't collapse onto each other because their translation stays the same relative to the root of the whole construction </p><p><img src='game:tools/images/modeldoc_editor/lock_translation_sample_bebop.png' />
<p>If you are setting up simple cloth or are just playing around with it, please leave at default</p>"
		"clothchain.extrude_sides"		"Extrude Sides"
		"clothchain.extrude_sides:help"		"<p>ClothChain can extrude the joint chain into a strip (to simulate flat tails, flags, banners, loincloth etc.) or a tube/sausage (to simulate more full structures like very thick braids of hair or thick tails).</p>
<p><i>Note that when Extrude Radius is 0, nothing is extruded.</i> So set the Radius to 1 or more</p>
<p>The Extrude Sides parameter is how many sides the figure has. 1 means extrude to the left. 2 means extrude left and right. 3 means extrude into a triangular-cross-shape tube. Etc.</p>
<p><img src='game:tools/images/model_editor/clothchain_extrude.png' /></p>"
		"clothchain.extrude_radius"		"Extrude Radius"
		"clothchain.extrude_radius:help"		"<p>ClothChain can extrude the joint chain into a strip or a tube/sausage. The thickness of that strip/tube/sausage is determined by Extrude Radius. When Radius is 0, nothing is extruded</p>
<p><img src='game:tools/images/model_editor/clothchain_extrude_radius.png' /></p>"
		"clothchain.extrude_twist"		"Extrude Twist"
		"clothchain.extrude_twist:help"		"<p>ClothChain can extrude the joint chain into a strip or a tube/sausage. Sometimes it's necessary to orient that structure, and Extrude Twist determines how much to twist the resulting extrusion. This parameters makes no sense in the default case of Extrude Sides = 0. In the example below, optimal twist is 90° from default because it aligns the best with render mesh and implied dynamics of the tail. 180° is the same as 360° is the same as 0°</p>
<p><img src='game:tools/images/model_editor/clothchain_extrude_twist.png' /></p>"
		"clothchain.drag"		"Extra Drag"
		"clothchain.drag:shorthelp"		"Air drag. Range: 0..1"
		"clothchain.drag:help"		"<p>In addition to goal damping, there's additional drag to apply to cloth. The drag is very simple, it just robs cloth vertices of their velocity regardless of topology</p>"
		"clothchain.mass"		"Mass"
		"clothchain.mass:help"		"<p>Mass is technically the mass of the corresponding cloth vertex. It does <i>not</i> behave in a way artistic mass behaves: the cloth won't behave differently if you set all node masses to 10 or 1000. Only the ratio of masses in neighbor vertices matters, so if you want a long chain with heavy vertex at the end, you can set that heavy vertex mass to 10 and the chain will behave differently</p>"
		"clothchain.bend_spring"		"Bend Spring"
		"clothchain.bend_spring:help"		"<p>Cloth chain relies on joint hierarchy information to generate cloth around the joints</p>
<p>All the different types of springs are generated by going to parent, grandparent or great-grandparent of the joint</p>
<style>
table {
  border: 2px solid black;
  margin: 2px
  padding: 3px;
}
.selected {padding:3px;background-color:yellow;text-color:black;}
</style>
<table style=\"border:2px solid yellow;\"><th><tr font=\"large\"><td>Stretch</td><td>Bend</td><td>Torsion</td></tr></th>
<tr>
	<td>Stretch springs are red. Connect structurally closest elements.</td>
	<td class=\"selected\" style=\"background-color:yellow;color:black;\"><b>Bend</b> springs are yellow. They skip a parent.</td>
	<td>Torsion springs are blue. They skip <b>2</b> parents.</td>
</tr>
<tr>
	<td><img src='game:tools/images/model_editor/clothchain_stretch.jpg' /></td>
	<td><img src='game:tools/images/model_editor/clothchain_bend.jpg' /></td>
	<td><img src='game:tools/images/model_editor/clothchain_torsion.jpg' /></td>
<tr>"
		"clothchain.torsion_spring"		"Torsion Spring"
		"clothchain.torsion_spring:help"		"<p>Cloth chain relies on joint hierarchy information to generate cloth around the joints</p>
<p>All the different types of springs are generated by going to parent, grandparent or great-grandparent of the joint</p>
<style>
table {
  border: 2px solid black;
  margin: 2px
  padding: 3px;
}
.selected {padding:3px;background-color:yellow;text-color:black;}
</style>
<table style=\"border:2px solid yellow;\"><th><tr font=\"large\"><td>Stretch</td><td>Bend</td><td>Torsion</td></tr></th>
<tr>
	<td>Stretch springs are red. Connect structurally closest elements.</td>
	<td>Bend springs are yellow. They skip a parent.</td>
	<td class=\"selected\" style=\"background-color:yellow;color:black;\"><b>Torsion</b> springs are blue. They skip <b>2</b> parents.</td>
</tr>
<tr>
	<td><img src='game:tools/images/model_editor/clothchain_stretch.jpg' /></td>
	<td><img src='game:tools/images/model_editor/clothchain_bend.jpg' /></td>
	<td><img src='game:tools/images/model_editor/clothchain_torsion.jpg' /></td>
<tr>"
		"clothchain.gravity_z"		"Gravity"
		"clothchain.gravity_z:shorthelp"		"Normal Gravity (-Z) affecting the cloth vertices"
		"clothchain.gravity_z:help"		"Gravity of 1 is normal gravity. 0 will make your cloth float, and -1 will pull it upward."
		"clothchain.suspender"		"Suspender Springs"
		"clothchain.suspender:help"		"When you have a long cape or banner, you can prevent it from stretching too much by creating suspender springs. They connect vertices to the closest fixed vertex."
		"clothchain.stray_radius_stretchiness"		"Stray Radius Stretchiness"
		"clothchain.stray_radius_stretchiness:help"		"<p>Every cloth vertex has the animated position, defined by animation</p>
<p>If stray radius is set, it defines how far it can stray from that position.</p>
<p>Stretchiness kicks in once cloth vertex is beyond stray radius. You can regulate how hard the vertex is returned into the bubble around the animated position within the stray radius.</p>"
		"clothchain.friction"		"Friction"
		"clothchain.friction:help"		"Friction refers to friction against collision objects (spheres, capsules or boxes). It has no other effect on cloth unless it is in contact with colliders."
		"clothchain.end_effector"		"End Effector"
		"clothchain.end_effector:help"		"When End Effector is set to non-zero value, a new cloth vertex is created, extruded by that value along X axis from the joint. This is useful to create that extra virtual joint at the end of the chain that is not needed for animation, but is useful to simulate for dynamic effects. Set it to negative value if you want to extrude along -X"
		"clothchain.twist_relax:help"		"<p><b>Experimental</b></p>
<p>The orientation of a bone affected by cloth is usually determined by the closest 3+ cloth vertices/nodes. Sometimes however there are only 1 or 2 vertices available, as for example in case of unextruded ropes/chains. They are the most efficient to simulate, but they don't provide enough information to unambiguously determine bone orientations. In that case, cloth prior to 2022 was taking the root of the chain orientation, and interpolated that along the chain.</p>

<p>Depending on the chain structure, this may cause quick flips of the chains, e.g. tassles that are modeled 90 degrees away from their relaxed state. Sometimes it may cause cloth to ignore twisting motion from animation. For example here is a chain of 3 joints that goes from bottom to top, root at the bottom and the tip (at the top) are both static (not simulating) but with free rotation. When the top is rotated, the chain doesn't twist because it takes the twist from the root, that isn't twisting.</p>

<p>Here is another example of two chains connecing in the middle. The left half is twisted, and the right isn't, and they meet in the middle. The twists are conflicting and have an unpleasant discontinuity in the middle.

<p>Twist Relax attribute is made to distribute the twist along the chain softly. Think of the twist as flowing along the chain, including branches. The Twist Relax amount is how fast it flows. If you have both ends fixed (like in this example), this attribute will flow twist from both ends of the chain and balance out in the middle to create a pleasant falloff.</p>

<p><img src='game:tools/images/modeldoc_editor/twist_relax_0.png' />
<img src='game:tools/images/modeldoc_editor/twist_relax_1.png' /></p>
<p><img src='game:tools/images/modeldoc_editor/twist_relax_0a.png' /><img src='game:tools/images/modeldoc_editor/twist_relax_1a.png' /></p>"
		"clothchain.child_sibling_spring:help"		"<p>When there's a branch in cloth chain, sometimes you want the siblings to fall free. This is the default behavior.</p>

<p><img src='game:tools/images/modeldoc_editor/help_cloth_chain_branch0.png' />
</p>

<p>But sometimes you want them to keep structure. Then set the sibling attribute to non-zero (the value means stiffness of the spring between siblings).</p>

<p><img src='game:tools/images/modeldoc_editor/help_cloth_chain_branch1.png' />
</p>

<p>The important additional consideration in branchy ClothChains is that it's impossible to align all joints with their X pointing down to a child: you can't point axis X at both children at the same time. So, you usually need to also use Twist Relax (which doesn't have the requirement of joint alignment).</p>"
		"clothchain.stiff_hinge:help"		"<p>One way to resist bending is to add bend springs that connect child and grandparent. This works well to resist large (over 60 degree) bends, but does nothing to resist small but significant (5-15 degrees) bends.</p>

<p>Stiff Hinge affects all 3 nodes: child, parent and grandparent. It pulls them together along one line, and this scheme resists small bends very well, but doesn't resist large (over 60 degrees) bends very well.</p>

<p>So, depending on how stiff you want the bend resistance to be and at what angles, you might want to use Stiff Hinge, Bend spring attribute, or both at the same time in some cases when there can be very wide range of motion in some extreme or fasat animations.</p>"
		"clothchain.stiff_hinge_angle:help"		"When you use Stiff Hinge attribute, it can be too stiff. If you want to have some \"give\" in the bend, you have the option to set non-zero Stiff Hinge Angle (in degrees). This will allow the chain to bend up to that angle without any resistance, and stiff hinge algorithm will only kick in after that angle."
		"clothchain.motion_bias:help"		"<p>This is made specifically to model chains of old-style Source1 jigglebones that were perfect to model antennae. Bias of 0 will mean the motion is traveling from child to parent and parent to child equally. This will make your chain more like a normal rope. But if you want the parent to affect the motion of the child, but child <b>not</b> to affect the parent, set motion bias to 1. This will ensure that motino is traveling down the chain but not up the chain.</p>

<p>When used together with stiff hinge, this attribute ensure perfect stiffness of your antenna joint chain. So perfect that there's no springiness to the antenna at all, it'll be perfectly rigid unless you soften it up somehow. One way to soften it is to set the bias to less than 1 (try 0.5). It will allow some, but not, of the motion to travel up the chain.</p>
<p>Another variant would be to set Stiff Hinge Angle to something small (try 5), and Motion Bias to 1. This will keep the hinges perfectly stiff, but will allow for the bend up to specified angle</p>"
		"clothchain.extra_iterations:help"		"<p>Sometimes springs aren't stiff enough. Setting Extra Iterations to above 0 will effectively add the spring multiple times, so it'll be solved multiple times, so in large systems it will be stiffer.</p>

<p> This only makes sense in large systems because in small systems the spring will be solved the very first time, and solving it again won't change any behavior. You can only observe the difference in behavior in a large system, where there are many other springs tugging on cloth so that it makes sense to re-solve this spring after those other springs had the chance to move the joint</p>

<p><b>Use with caution</b>: this will affect performance if used a lot, and you get most of the benefits, if any, with very small numbers like 1 or 2. Usually setting it to higher number makes no difference but costs CPU. But in general, solving springs is very cheap and won't cost any CPU if just used sparingly here and there</p>"
	}
}
